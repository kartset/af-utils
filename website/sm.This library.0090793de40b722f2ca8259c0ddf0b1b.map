{"version":3,"sources":["webpack:///./lib/Context.js","webpack:///./lib/utils/useStore/index.js","webpack:///./lib/models/RowsSimple.js","webpack:///./lib/models/createList.js","webpack:///./lib/models/ScrollableRowsBase.js","webpack:///./lib/models/SegmentsTree.js","webpack:///./lib/models/VariableSizeScrollableRows.js","webpack:///./lib/models/FixedSizeScrollableRows.js","webpack:///./lib/models/VariableSizeList.js","webpack:///./lib/models/FixedSizeList.js","webpack:///./lib/utils/cx/index.js","webpack:///./lib/useApi/index.js","webpack:///./lib/common/HeightProvider.js","webpack:///./lib/common/ScrollContainer.js","webpack:///./lib/utils/extraPropsGetters/index.js","webpack:///./lib/List/common/Row.js","webpack:///./lib/List/common/Rows.js","webpack:///./lib/common/Scroller.js","webpack:///./lib/commonDefaultProps.js","webpack:///./lib/List/index.js"],"names":["createContext","useStore","StoreConstructor","dataRef","propsToMerge","scrollContainerRef","useRef","rowsContainerRef","finalDataRef","Store","current","useLayoutEffect","merge","Object","assign","rowsContainerNode","scrollContainerNode","useEffect","destructor","RowsSimple","constructor","parent","this","rows","length","createList","_class","BaseClass","super","getRowDataInitial","Error","ScrollableRowsBase","getVisibleRangeStart","scrollTop","estimatedRowHeight","newVisibleStartIndex","visibleRangeStart","Math","max","overscanRowsCount","newEndIndex","widgetHeight","min","Rows","visibleRowCount","remainder","overscanOffset","getDistanceBetweenIndexes","startIndex","params","RowsConstructor","extendObservable","scrollLeft","widgetWidth","getRowKey","undefined","getRowData","observable","ref","scrollToRow","index","node","clamp","scrollToStart","_applyDecoratedDescriptor","prototype","computed","getOwnPropertyDescriptor","action","SegmentsTree","minCacheOffset","cacheSize","N","cache","Uint32Array","l","Infinity","r","reallocateIfNeeded","defaultValue","currentCacheSize","newN","log2","fill","reset","calculateParentsInRange","endIndex","i","set","value","flush","Number","isFinite","getStartPositionForSum","dist","v","nodeIndex","res","VariableSizeScrollableRows","syncWidgetScrollHeight","widgetScrollHeight","sTree","total","rowsDomObserver","MutationObserver","runInAction","lastRowsRenderTimeStamp","performance","now","disposeCallbacks","shouldResetInvisibleRowHeights","push","autorun","delay","disconnect","observe","childList","subtree","rowHeightsSum","rowCounter","newHeight","child","firstElementChild","nextElementSibling","parseInt","getAttribute","offsetHeight","round","forEach","cb","FixedSizeScrollableRows","dispose","desctructor","distance","cx","baseClass","extraClass","useApi","useContext","Context","el","React","createElement","className","observer","cloneElement","style","height","ScrollContainer","forwardRef","_ref","children","onScroll","props","_objectWithoutPropertiesLoose","API","scrollHandler","useCallback","e","target","R","ResizeObserver","entries","offsetWidth","unobserve","_extends","tabIndex","HeightProvider","getPropsGetter","propName","data","dataIndex","getExtraProps","extraProps","getRowProps","Row","getRowExtraProps","rowIndex","rowData","propTypes","RowComponent","rangeFrom","rangeTo","result","rowKey","key","getVisibleRows","Component","virtualTopOffset","commonDefaultProps","fixedSize","List","RowComponentDefault","FixedSizeListStore","VariableSizeListStore","Provider","Scroller","defaultProps","memo"],"mappings":"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","file":"This library.efa95f95aaf35ce91da4.js","sourcesContent":["import { createContext } from \"react\";\nexport default /*#__PURE__*/createContext();","import { useRef, useEffect, useLayoutEffect } from \"react\";\n/*\r\n    dataRef is to call Data methods from outside( Data.scrollTo(), etc. ).\r\n    As it is not dom-related, I decided to avoid forwardRef\r\n*/\n\nconst useStore = (StoreConstructor, dataRef, propsToMerge) => {\n  const scrollContainerRef = useRef();\n  const rowsContainerRef = useRef();\n  const finalDataRef = useRef();\n  let Store = finalDataRef.current;\n\n  if (!Store || !(Store instanceof StoreConstructor)) {\n    Store = finalDataRef.current = new StoreConstructor();\n  }\n\n  if (dataRef) {\n    dataRef.current = Store;\n  }\n\n  useLayoutEffect(() => {\n    Store.merge(Object.assign({}, propsToMerge, {\n      rowsContainerNode: rowsContainerRef.current,\n      scrollContainerNode: scrollContainerRef.current\n    }));\n  });\n  useEffect(() => () => {\n    Store.destructor();\n  }, [Store]);\n  return [Store, scrollContainerRef, rowsContainerRef];\n};\n\nexport default useStore;","import { computed } from \"mobx\";\nimport groupBy from \"lodash/groupBy\";\nimport keyBy from \"lodash/keyBy\";\nimport times from \"lodash/times\";\n\nclass RowsSimple {\n  constructor(parent) {\n    this.parent = parent;\n  }\n\n  get visibleRowCount() {\n    return this.parent.rows.length;\n  }\n\n}\n\nexport default RowsSimple;","import RowsSimple from \"./RowsSimple\";\n\nconst createList = BaseClass => class extends BaseClass {\n  constructor() {\n    super(RowsSimple);\n  }\n\n};\n\nexport default createList;","import _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\n\nvar _class;\n\nimport { extendObservable, computed, action, observable } from \"mobx\";\nimport clamp from \"lodash/clamp\";\n\nconst getRowDataInitial = () => {\n  throw new Error(\"getRowData must be provided\");\n};\n\nlet ScrollableRowsBase = (_class = class ScrollableRowsBase {\n  get visibleRangeStart() {\n    return this.getVisibleRangeStart(this.scrollTop);\n  }\n\n  get startIndex() {\n    if (!this.estimatedRowHeight) {\n      return 0;\n    }\n\n    const [newVisibleStartIndex] = this.visibleRangeStart;\n    return Math.max(0, newVisibleStartIndex - this.overscanRowsCount);\n  }\n\n  get endIndex() {\n    if (!this.estimatedRowHeight) {\n      return 0;\n    }\n\n    const [newEndIndex] = this.getVisibleRangeStart(this.scrollTop + this.widgetHeight);\n    /*\r\n        getVisibleRangeStart works by \"strict less\" algo. It is good for startIndex,\r\n        but for endIndex we need \"<=\", so adding 1 artificially.\r\n    */\n\n    return Math.min(newEndIndex + 1 + this.overscanRowsCount, this.Rows.visibleRowCount);\n  }\n\n  get virtualTopOffset() {\n    const [newVisibleStartIndex, remainder] = this.visibleRangeStart;\n    const overscanOffset = this.getDistanceBetweenIndexes(this.startIndex, newVisibleStartIndex);\n    return this.scrollTop - remainder - overscanOffset;\n  }\n\n  merge(params) {\n    Object.assign(this, params);\n  }\n\n  constructor(RowsConstructor) {\n    extendObservable(this, {\n      rows: [],\n      overscanRowsCount: 0,\n      estimatedRowHeight: 0,\n      scrollLeft: 0,\n      scrollTop: 0,\n      widgetHeight: 0,\n      widgetWidth: 0,\n      getRowKey: undefined,\n      getRowData: getRowDataInitial,\n      rowsContainerNode: null,\n      scrollContainerNode: null\n    }, {\n      rowsContainerNode: observable.ref,\n      scrollContainerNode: observable.ref\n    });\n    this.Rows = new RowsConstructor(this);\n  }\n\n  destructor() {}\n\n  scrollToRow(index) {\n    const node = this.scrollContainerNode;\n\n    if (node) {\n      node.scrollTop = this.getDistanceBetweenIndexes(0, clamp(index, 0, this.Rows.visibleRowCount));\n    }\n\n    return this;\n  }\n\n  scrollToStart() {\n    return this.scrollToRow(0);\n  }\n\n}, (_applyDecoratedDescriptor(_class.prototype, \"visibleRangeStart\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"visibleRangeStart\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"startIndex\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"startIndex\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"endIndex\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"endIndex\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"virtualTopOffset\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"virtualTopOffset\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"merge\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"merge\"), _class.prototype)), _class);\n;\nexport default ScrollableRowsBase;","class SegmentsTree {\n  constructor(minCacheOffset) {\n    this.minCacheOffset = minCacheOffset || 15;\n    this.cacheSize = 0;\n    this.N = 0;\n    this.cache = new Uint32Array(1);\n    this.l = +Infinity;\n    this.r = -Infinity;\n  }\n\n  reallocateIfNeeded(cacheSize, defaultValue) {\n    const currentCacheSize = this.cacheSize;\n\n    if (cacheSize !== currentCacheSize) {\n      this.cacheSize = cacheSize;\n      const newN = 2 << Math.log2(cacheSize, this.minCacheOffset);\n\n      if (newN !== this.N) {\n        this.N = newN;\n        this.cache = new Uint32Array(newN << 1);\n      } else if (currentCacheSize > cacheSize) {\n        this.cache.fill(0, newN + cacheSize, newN + currentCacheSize);\n      }\n    }\n\n    this.reset(defaultValue);\n  }\n\n  reset(defaultValue) {\n    const {\n      cache,\n      N,\n      cacheSize\n    } = this;\n    cache.fill(defaultValue, N, N + cacheSize);\n    this.calculateParentsInRange(0, cacheSize);\n  }\n\n  calculateParentsInRange(startIndex, endIndex) {\n    const {\n      cache,\n      N\n    } = this;\n\n    for (endIndex += N, startIndex += N; endIndex >>= 1;) {\n      for (let i = startIndex >>= 1; i <= endIndex; i++) {\n        cache[i] = cache[i << 1] + cache[i << 1 | 1];\n      }\n    }\n  }\n\n  get total() {\n    return this.cache[1];\n  }\n\n  set(index, value) {\n    const {\n      cache,\n      N\n    } = this;\n\n    if (cache[N + index] !== value) {\n      cache[N + index] = value;\n      this.l = Math.min(this.l, index);\n      this.r = Math.max(this.r, index);\n    }\n  }\n\n  flush() {\n    const {\n      l,\n      r\n    } = this;\n\n    if (Number.isFinite(l)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.log(\"Updating heights in range: %d - %d\", l, r);\n      }\n\n      this.calculateParentsInRange(l, r);\n      this.l = +Infinity;\n      this.r = -Infinity;\n      return true;\n    }\n\n    return false;\n  }\n\n  getStartPositionForSum(dist) {\n    const {\n      cache,\n      N\n    } = this;\n    let nodeIndex = 1,\n        v;\n\n    while (nodeIndex < N) {\n      v = cache[nodeIndex <<= 1];\n\n      if (dist >= v) {\n        dist -= v;\n        nodeIndex |= 1;\n      }\n    }\n\n    return [nodeIndex - N, dist];\n  }\n\n  getDistanceBetweenIndexes(startIndex, endIndex) {\n    const {\n      cache,\n      N\n    } = this;\n    let res = 0;\n\n    for (startIndex += N, endIndex += N; startIndex < endIndex; startIndex >>= 1, endIndex >>= 1) {\n      if (startIndex & 1) {\n        res += cache[startIndex++];\n      }\n\n      if (endIndex & 1) {\n        res += cache[--endIndex];\n      }\n    }\n\n    ;\n    return res;\n  }\n\n}\n\nexport default SegmentsTree;","import _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\n\nvar _class, _temp;\n\nimport ScrollableRowsBase from \"./ScrollableRowsBase\";\nimport SegmentsTree from \"./SegmentsTree\";\nimport { extendObservable, autorun, action, runInAction } from \"mobx\";\nconst ROW_MEASUREMENT_DEBOUNCE_INTERVAL = 200;\nlet VariableSizeScrollableRows = (_class = (_temp = class VariableSizeScrollableRows extends ScrollableRowsBase {\n  syncWidgetScrollHeight() {\n    this.widgetScrollHeight = this.sTree.total;\n  }\n\n  getVisibleRangeStart(dist) {\n    const {\n      widgetScrollHeight,\n      estimatedRowHeight,\n      sTree\n    } = this;\n\n    if (widgetScrollHeight && estimatedRowHeight) {\n      return sTree.getStartPositionForSum(dist);\n    }\n\n    return [0, 0];\n  }\n\n  constructor(RowsConstructor) {\n    super(RowsConstructor);\n    this.rowsDomObserver = new MutationObserver(() => runInAction(() => {\n      this.lastRowsRenderTimeStamp = performance.now();\n    }));\n    this.disposeCallbacks = [];\n    this.sTree = new SegmentsTree();\n    extendObservable(this, {\n      widgetScrollHeight: 0,\n      lastRowsRenderTimeStamp: 0,\n\n      /*\r\n          When all row heights are different,\r\n          we must \"predict\" them on the left of startIndex and on the right of endIndex(where they are invisible),\r\n          basing on what we know: heights between startIndex and endIndex.\r\n          Using simple average by default.\r\n      */\n      shouldResetInvisibleRowHeights: true\n    });\n    this.disposeCallbacks.push(autorun(() => {\n      this.sTree.reallocateIfNeeded(this.rows.length && this.Rows.visibleRowCount, this.estimatedRowHeight);\n      this.syncWidgetScrollHeight();\n    }), autorun(() => {\n      if (this.widgetWidth) {\n        this.merge({\n          shouldResetInvisibleRowHeights: true\n        });\n      }\n    }, {\n      delay: 200\n    }), autorun(() => {\n      this.rowsDomObserver.disconnect();\n\n      if (this.rowsContainerNode) {\n        this.rowsDomObserver.observe(this.rowsContainerNode, {\n          childList: true,\n          subtree: true\n        });\n      }\n    }), autorun(() => {\n      const node = this.rowsContainerNode;\n\n      if (node && this.lastRowsRenderTimeStamp) {\n        const {\n          sTree\n        } = this;\n        let rowHeightsSum = 0,\n            rowCounter = 0;\n        /*\r\n            Some benchmarks inspire me to use nextElementSibling\r\n            https://jsperf.com/nextsibling-vs-childnodes-increment/2\r\n        */\n\n        for (let child = node.firstElementChild, newHeight, index; child; child = child.nextElementSibling, rowCounter++) {\n          /*\r\n              * aria-rowindex is counted from 1 according to w3c spec;\r\n              * parseInt with radix is 2x faster, then +, -, etc.\r\n                  https://jsperf.com/number-vs-parseint-vs-plus/116\r\n          */\n          index = parseInt(child.getAttribute(\"aria-rowindex\"), 10) - 1;\n\n          if (process.env.NODE_ENV !== \"production\" && Number.isNaN(index)) {\n            throw new Error(\"aria-rowindex attribute must be present on each row. Look at default Row implementations.\");\n          }\n\n          newHeight = child.offsetHeight;\n          rowHeightsSum += newHeight;\n          sTree.set(index, newHeight);\n        }\n\n        if (this.shouldResetInvisibleRowHeights) {\n          this.merge({\n            estimatedRowHeight: Math.round(rowHeightsSum / rowCounter),\n            shouldResetInvisibleRowHeights: false\n          });\n        } else if (sTree.flush()) {\n          this.syncWidgetScrollHeight();\n        }\n      }\n    }, {\n      delay: ROW_MEASUREMENT_DEBOUNCE_INTERVAL\n    }));\n  }\n\n  destructor() {\n    this.disposeCallbacks.forEach(cb => cb());\n    super.destructor();\n  }\n\n  getDistanceBetweenIndexes(startIndex, endIndex) {\n    if (!this.estimatedRowHeight) {\n      return 0;\n    }\n\n    return this.sTree.getDistanceBetweenIndexes(startIndex, endIndex);\n  }\n\n}, _temp), (_applyDecoratedDescriptor(_class.prototype, \"syncWidgetScrollHeight\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"syncWidgetScrollHeight\"), _class.prototype)), _class);\n;\nexport default VariableSizeScrollableRows;","import _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\n\nvar _class;\n\nimport { computed, autorun } from \"mobx\";\nimport ScrollableRowsBase from \"./ScrollableRowsBase\";\nlet FixedSizeScrollableRows = (_class = class FixedSizeScrollableRows extends ScrollableRowsBase {\n  constructor(RowsConstructor) {\n    super(RowsConstructor);\n    this.dispose = autorun(() => {\n      if (this.widgetWidth) {\n        const node = this.rowsContainerNode;\n\n        if (node) {\n          const {\n            firstElementChild\n          } = node;\n\n          if (firstElementChild) {\n            this.estimatedRowHeight = firstElementChild.offsetHeight;\n          }\n        }\n      }\n    }, {\n      delay: 200\n    });\n  }\n\n  desctructor() {\n    this.dispose();\n    super.destructor();\n  }\n\n  get widgetScrollHeight() {\n    return this.estimatedRowHeight * this.Rows.visibleRowCount;\n  }\n\n  getVisibleRangeStart(distance) {\n    const {\n      estimatedRowHeight\n    } = this;\n    return estimatedRowHeight ? [distance / estimatedRowHeight | 0, distance % estimatedRowHeight] : [0, 0];\n  }\n\n  getDistanceBetweenIndexes(startIndex, endIndex) {\n    return this.estimatedRowHeight * (endIndex - startIndex);\n  }\n\n}, (_applyDecoratedDescriptor(_class.prototype, \"widgetScrollHeight\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"widgetScrollHeight\"), _class.prototype)), _class);\n;\nexport default FixedSizeScrollableRows;","import createList from \"./createList\";\nimport VariableSizeScrollableRows from \"./VariableSizeScrollableRows\";\nexport default createList(VariableSizeScrollableRows);","import createList from \"./createList\";\nimport FixedSizeScrollableRows from \"./FixedSizeScrollableRows\";\nexport default createList(FixedSizeScrollableRows);","const cx = (baseClass, extraClass) => extraClass ? baseClass + \" \" + extraClass : baseClass;\n\nexport default cx;","import { useContext } from \"react\";\nimport Context from \"../Context\";\n\nconst useApi = () => useContext(Context);\n\nexport default useApi;","import React, { cloneElement } from \"react\";\nimport useApi from \"../useApi\";\nimport { observer } from \"mobx-react-lite\";\nconst el = /*#__PURE__*/React.createElement(\"div\", {\n  \"aria-hidden\": \"true\",\n  className: \"afvscr-height-provider\"\n});\n\nconst HeightProvider = () => /*#__PURE__*/cloneElement(el, {\n  style: {\n    height: useApi().widgetScrollHeight\n  }\n});\n\nexport default observer(HeightProvider);","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React, { forwardRef, useCallback, useEffect } from \"react\";\nimport cx from \"../utils/cx\";\nimport HeightProvider from \"./HeightProvider\";\nimport useApi from \"../useApi\";\nconst ScrollContainer = /*#__PURE__*/forwardRef((_ref, ref) => {\n  let {\n    className,\n    children,\n    onScroll\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"className\", \"children\", \"onScroll\"]);\n\n  const API = useApi();\n  const scrollHandler = useCallback(e => {\n    const {\n      scrollTop,\n      scrollLeft\n    } = e.target;\n    API.merge({\n      scrollLeft,\n      scrollTop\n    });\n\n    if (onScroll) {\n      onScroll(e);\n    }\n  }, [onScroll]);\n  useEffect(() => {\n    const el = ref.current;\n    const R = new ResizeObserver(entries => {\n      if (entries.length === 1) {\n        /*\r\n            using target.offsetWidth instead of contentRect.width, because we need border-box sizing, \r\n            and { box: border-box } option does not work here\r\n        */\n        const {\n          offsetWidth,\n          offsetHeight\n        } = entries[0].target;\n        API.merge({\n          widgetHeight: Math.round(offsetHeight),\n          widgetWidth: Math.round(offsetWidth)\n        });\n      }\n    });\n    R.observe(el);\n    return () => {\n      R.unobserve(el);\n    };\n  }, []);\n  /*\r\n      tabIndex=\"0\" is for proper keyboard nav\r\n      https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\r\n  */\n\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    tabIndex: \"0\",\n    className: cx(\"afvscr-scroll-container\", className),\n    ref: ref,\n    onScroll: scrollHandler\n  }, props), /*#__PURE__*/React.createElement(HeightProvider, null), children);\n});\nexport default ScrollContainer;","const getPropsGetter = propName => (data, index, dataIndex, getExtraProps) => {\n  /* avoiding double destructurization via getExtraProps, so making prop object once */\n  const props = {\n    [propName]: index + 1\n  };\n\n  if (getExtraProps) {\n    const extraProps = getExtraProps(data, index, dataIndex);\n\n    if (extraProps) {\n      if (process.env.NODE_ENV !== \"production\") {\n        if (extraProps.hasOwnProperty(propName)) {\n          throw new Error(\"getExtraProps must not override \" + propName);\n        }\n      }\n\n      Object.assign(props, extraProps);\n    }\n  }\n\n  return props;\n};\n\nexport const getRowProps = getPropsGetter(\"aria-rowindex\");\nexport const getCellProps = getPropsGetter(\"aria-colindex\");","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getRowProps } from \"../../utils/extraPropsGetters\";\n\nconst Row = ({\n  getRowData,\n  getRowExtraProps,\n  rowIndex\n}) => {\n  const rowData = getRowData(rowIndex);\n  return /*#__PURE__*/React.createElement(\"div\", getRowProps(rowData, rowIndex, rowIndex, getRowExtraProps), rowData);\n};\n\nRow.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  getRowData: PropTypes.func.isRequired,\n  rowIndex: PropTypes.number.isRequired,\n  getRowExtraProps: PropTypes.func\n} : {};\nexport default Row;","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport useApi from \"../../useApi\";\n\nconst getVisibleRows = (rangeFrom, rangeTo, getRowData, getRowKey, getRowExtraProps, RowComponent) => {\n  const result = [];\n\n  for (let rowKey; rangeFrom < rangeTo; rangeFrom++) {\n    rowKey = getRowKey ? getRowKey(rangeFrom) : rangeFrom;\n    result.push( /*#__PURE__*/React.createElement(RowComponent, {\n      getRowExtraProps: getRowExtraProps,\n      rowIndex: rangeFrom,\n      key: rowKey,\n      getRowData: getRowData\n    }));\n  }\n\n  return result;\n};\n\nconst Rows = ({\n  getRowExtraProps,\n  RowComponent\n}) => {\n  const {\n    startIndex,\n    endIndex,\n    getRowData,\n    getRowKey\n  } = useApi();\n  return getVisibleRows(startIndex, endIndex, getRowData, getRowKey, getRowExtraProps, RowComponent);\n};\n\nexport default observer(Rows);","import React from \"react\";\nimport useApi from \"../useApi\";\nimport { observer } from \"mobx-react-lite\";\n\nconst Scroller = ({\n  Component\n}) => {\n  const {\n    virtualTopOffset\n  } = useApi();\n  /*\r\n      Hmm, I can't put here more than ~ 3 000 000. Maybe need to put one more row in case this height is > 3 000 000\r\n  */\n\n  return /*#__PURE__*/React.createElement(Component, {\n    className: \"afvscr-scroller\",\n    \"aria-hidden\": \"true\",\n    style: {\n      height: virtualTopOffset\n    }\n  });\n};\n\nexport default observer(Scroller);","const commonDefaultProps = {\n  fixedSize: false,\n  rows: [],\n  overscanRowsCount: 4,\n  estimatedRowHeight: 16\n};\nexport default commonDefaultProps;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React, { memo } from \"react\";\nimport PropTypes from \"prop-types\";\nimport Context from \"../Context\";\nimport useStore from \"../utils/useStore\";\nimport VariableSizeListStore from \"../models/VariableSizeList\";\nimport FixedSizeListStore from \"../models/FixedSizeList\";\nimport ScrollContainer from \"../common/ScrollContainer\";\nimport RowComponentDefault from \"./common/Row\";\nimport Rows from \"./common/Rows\";\nimport Scroller from \"../common/Scroller\";\nimport commonPropTypes from \"../commonPropTypes\";\nimport commonDefaultProps from \"../commonDefaultProps\";\nimport cx from \"../utils/cx\";\n\nconst List = (_ref) => {\n  let {\n    fixedSize,\n    getRowData,\n    getRowKey,\n    getRowExtraProps,\n    estimatedRowHeight,\n    rows,\n    overscanRowsCount,\n    RowComponent = RowComponentDefault,\n    dataRef,\n    className\n  } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, [\"fixedSize\", \"getRowData\", \"getRowKey\", \"getRowExtraProps\", \"estimatedRowHeight\", \"rows\", \"overscanRowsCount\", \"RowComponent\", \"dataRef\", \"className\"]);\n\n  const [Store, scrollContainerRef, rowsContainerRef] = useStore(fixedSize ? FixedSizeListStore : VariableSizeListStore, dataRef, {\n    getRowData,\n    getRowKey,\n    overscanRowsCount,\n    estimatedRowHeight,\n    rows\n  });\n  return /*#__PURE__*/React.createElement(Context.Provider, {\n    value: Store\n  }, /*#__PURE__*/React.createElement(ScrollContainer, _extends({\n    className: cx(\"afvscr-list-wrapper\", className),\n    ref: scrollContainerRef\n  }, props), /*#__PURE__*/React.createElement(Scroller, {\n    Component: \"div\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    ref: rowsContainerRef\n  }, /*#__PURE__*/React.createElement(Rows, {\n    RowComponent: RowComponent,\n    getRowExtraProps: getRowExtraProps\n  }))));\n};\n\nList.propTypes = process.env.NODE_ENV !== \"production\" ? commonPropTypes : {};\nList.defaultProps = Object.assign({}, commonDefaultProps, {\n  /*\r\n      For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.\r\n      If RowComponent should be wrapped my mobx observer - non-memo version should be imported.\r\n      memo(observer(RowComponentDefault)) will do the trick.\r\n  */\n  RowComponent: /*#__PURE__*/memo(RowComponentDefault)\n});\nexport default /*#__PURE__*/memo(List);"],"sourceRoot":""}