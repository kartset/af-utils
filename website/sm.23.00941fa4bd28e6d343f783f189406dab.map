{"version":3,"sources":["webpack:///./src/utils/isPositionStickySupported/index.js","webpack:///./src/Context.js","webpack:///./src/utils/useStore/index.js","webpack:///./src/models/RowsComplex.js","webpack:///./src/models/createTable.js","webpack:///./src/models/ScrollableRowsBase.js","webpack:///./src/models/FixedSizeTable.js","webpack:///./src/models/FixedSizeScrollableRows.js","webpack:///./src/models/RowsSimple.js","webpack:///./src/models/VariableSizeTable.js","webpack:///./src/models/createList.js","webpack:///./src/models/VariableSizeList.js","webpack:///./src/models/VariableSizeScrollableRows.js","webpack:///./src/utils/extraPropsGetters/index.js","webpack:///./src/Table/common/Row.js","webpack:///./src/Table/common/Cell.js","webpack:///./src/Table/common/TotalsCell.js","webpack:///./src/utils/cx/index.js","webpack:///./src/common/RowCountWarningContainer.js","webpack:///./src/useApi/index.js","webpack:///./src/Table/common/Colgroup.js","webpack:///./src/Table/NonSticky/TableWrapper/index.js","webpack:///./src/Table/common/HeaderCells.js","webpack:///./src/Table/common/Thead.js","webpack:///./src/Table/common/FooterCells.js","webpack:///./src/Table/common/Tfoot.js","webpack:///./src/Table/common/GroupRow.js","webpack:///./src/Table/common/Rows.js","webpack:///./src/Table/common/Tbody.js","webpack:///./src/Table/common/BodyTable.js","webpack:///./src/Table/NonSticky/useColWidthsResizeObserver/index.js","webpack:///./src/common/Scroller.js","webpack:///./src/Table/common/TbodyScroller.js","webpack:///./src/common/HeightProvider.js","webpack:///./src/common/ScrollContainer.js","webpack:///./src/Table/NonSticky/index.js","webpack:///./src/Table/Sticky/index.js","webpack:///./src/commonDefaultProps.js","webpack:///./src/Table/index.js","webpack:///./websiteSrc/examples/table/simple.js"],"names":["elStyle","document","createElement","style","cssText","map","p","join","isSupported","position","includes","isPositionStickySupported","createContext","useStore","StoreConstructor","dataRef","propsToMerge","scrollContainerRef","useRef","rowsContainerRef","finalDataRef","Store","current","useEffect","merge","rowsContainerNode","scrollContainerNode","destructor","TotalsCachePart","rows","dataKey","this","parent","rowCount","res","columnsByDataKey","col","getCellData","getRowData","fn","i","sum","count","computed","RowsComplex","modifyAggregators","arg","Object","assign","aggregators","mapValues","totals","v","k","keyBy","columns","times","filter","length","rowIndexesArray","row","every","value","type","toString","group","all","filtered","groupBy","sort","sign","grouped","a","b","row1","row2","cell1","cell2","reduce","sorted","result","groupArr","groupName","push","flat","observable","action","Uint32Array","average","createTable","BaseClass","Rows","extendObservable","headlessMode","tbodyColumnWidths","refreshTotalsForColumnRaw","cellDataGetter","curTotals","curCachePart","totalsCache","totalType","oldVal","newVal","tmpSum","j","undefined","reduceRange","add","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","Math","process","emit","BASIC_OBSERVABLE_FIELDS","overscanRowsCount","estimatedRowHeightFallback","scrollLeft","scrollTop","widgetHeight","widgetWidth","getRowKey","Error","ScrollableRowsBase","ref","params","getVisibleRangeStart","estimatedRowHeight","newVisibleStartIndex","visibleRangeStart","max","newEndIndex","min","visibleRowCount","remainder","overscanOffset","getDistanceBetweenIndexes","startIndex","scrollToRow","index","node","clamp","scrollToStart","keepAlive","distance","endIndex","firstElementChild","offsetHeight","RowsSimple","createList","rowsDomObserver","MutationObserver","runInAction","lastRowsRenderTimeStamp","performance","now","disposeCallbacks","widgetScrollHeight","shouldResetInvisibleRowHeights","autorun","sTree","N","fill","calculateParentsInRange","disconnect","observe","childList","subtree","reaction","newHeight","l","r","rowHeightsSum","rowCounter","child","nextElementSibling","parseInt","getAttribute","round","delay","dist","nodeIndex","log2","forEach","cb","getPropsGetter","propName","data","dataIndex","getExtraProps","props","extraProps","getRowProps","getCellProps","Row","CellComponent","getRowExtraProps","getCellExtraProps","rowDataIndex","rowIndex","rowData","column","columnIndex","visibility","FinalCellComponent","key","propTypes","Cell","getCellDataDefault","render","getEmptyCellData","format","cellData","Total","observer","cache","showSummaryType","summaryType","formatTotal","title","className","TotalsCell","cellTotals","cx","baseClass","extraClass","RowCountWarningContainer","useApi","useContext","Context","Colgroup","useTbodyWidths","background","border","width","TableWrapper","children","marginLeft","tbodyColumnWidthsSum","aria-colcount","HeaderCells","colSort","label","data-sortable","aria-colindex","aria-sort","Thead","trRef","getCellStyle","API","clickHandler","useCallback","e","colIndex","target","ctrlKey","onClick","memo","FooterCells","TotalsCellComponent","curTotalsCache","Tfoot","GroupRow","groupKey","colSpan","RowComponent","orderedRows","rangeFrom","rangeTo","rowKey","idx","getVisibleRows","Tbody","tbodyRef","BodyTable","aria-rowcount","useColWidthsResizeObserver","observerRef","mutationObserverRef","RO","MO","ResizeObserver","entries","offsetWidth","addedNodes","removedNodes","unobserve","trNode","Scroller","Component","virtualTopOffset","aria-hidden","height","TbodyScroller","el","HeightProvider","cloneElement","ScrollContainer","forwardRef","onScroll","scrollHandler","R","tabIndex","NonSticky","widthsObserverRef","Sticky","commonDefaultProps","fixedSize","Table","rowCountWarningsTable","headless","nonSticky","FixedSizeTableStore","VariableSizeTableStore","ComponentVariant","StickyComponent","NonStickyComponent","Provider","defaultProps","RowComponentDefault","CellComponentDefault","TotalsCellComponentDefault","RowCountWarningContainerDefault","c","SimpleTable"],"mappings":"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","file":"23.47ae0b4df18965751a06.js","sourcesContent":["const elStyle = document.createElement( \"a\" ).style;\nelStyle.cssText = [ \"\", \"-webkit-\", \"-ms-\" ].map( p => `position:${p}sticky` ).join( \";\" );\n\nconst isSupported = elStyle.position.includes( \"sticky\" );\n\nconst isPositionStickySupported = () => isSupported;\n\nexport default isPositionStickySupported;","import { createContext } from \"react\";\n\nexport default createContext();","import { useRef, useEffect } from \"react\";\n\n/*\n    dataRef is to call Data methods from outside( Data.scrollTo(), etc. ).\n    As it is not dom-related, I decided to avoid forwardRef\n*/\nconst useStore = ( StoreConstructor, dataRef, propsToMerge ) => {\n\n    const scrollContainerRef = useRef();\n    const rowsContainerRef = useRef();\n\n    const finalDataRef = useRef();\n\n    let Store = finalDataRef.current;\n\n    if( !Store || !( Store instanceof StoreConstructor ) ){\n        Store = finalDataRef.current = new StoreConstructor();\n    }\n\n    if( dataRef ){\n        dataRef.current = Store;\n    }\n\n    useEffect(() => {\n        Store.merge({\n            ...propsToMerge,\n            rowsContainerNode: rowsContainerRef.current,\n            scrollContainerNode: scrollContainerRef.current\n        });\n    });\n\n    useEffect(() => () => {\n        Store.destructor();\n    }, [ Store ]);\n\n    return [ Store, scrollContainerRef, rowsContainerRef ];\n};\n\nexport default useStore;","import { computed, action, observable } from \"mobx\";\nimport groupBy from \"lodash/groupBy\";\nimport mapValues from \"lodash/mapValues\";\nimport keyBy from \"lodash/keyBy\";\nimport times from \"lodash/times\";\nimport reduce from \"lodash/reduce\";\n\n/*\n    {\n        filter: [\n            {\n                dataKey: \"example\",\n                value: \"ssss\",\n                type: \"includes\"\n            }\n        ],\n        group: {\n            dataKey: \"example2\",\n            value: \"\",\n            type: \"default\"\n        },\n        sort: {\n            dataKey: \"example3\",\n            value: \"ascending\",\n            type: \"numeric\"\n        }\n    }\n*/\n\nclass TotalsCachePart {\n\n    constructor( rows, dataKey ){\n        this.rows = rows;\n        this.dataKey = dataKey;\n    }\n\n    @computed get count(){\n        return this.rows.parent.rowCount;\n    }\n\n    @computed get sum(){\n        let res = 0;\n        const { rows: { columnsByDataKey, parent }, dataKey } = this;\n        const col = columnsByDataKey[ dataKey ];\n        const { getCellData, getRowData, rowCount } = parent;\n        const fn = col.getCellData || getCellData;\n        for( let i = 0, row, cellData; i < rowCount; i++ ){\n            row = getRowData( i );\n            cellData = fn( row, i, dataKey );\n            res += cellData;\n        }\n        return res;\n    }\n\n    @computed get average(){\n        return this.sum / this.count;\n    }\n};\n\nclass RowsComplex {\n\n    constructor( parent ){\n        this.parent = parent;\n    }\n\n    @observable\n    aggregators = {\n        group: {\n            dataKey: \"country\",\n            value: \"\",\n            type: \"default\"\n        }\n    };\n\n    @action\n    modifyAggregators( arg ){\n        Object.assign( this.aggregators, arg );\n    }\n\n    @computed get totalsCache(){\n        return mapValues( this.parent.totals, ( v, k ) => new TotalsCachePart( this, k ) );\n    }\n\n    @computed get columnsByDataKey(){\n        return keyBy( this.parent.columns, \"dataKey\" );\n    }\n\n    @computed get rowIndexesArray(){\n        return times( this.parent.rowCount );\n    }\n\n    @computed get filtered(){\n\n        const { columnsByDataKey, parent } = this;\n        const { getCellData, getRowData } = parent;\n        const { filter } = this.aggregators;\n\n        if( !getCellData || !filter || !filter.length ){\n            return this.rowIndexesArray;\n        }\n\n        return this.rowIndexesArray.filter( i => {\n            const row = getRowData( i );\n            return filter.every(({ dataKey, value, type }) => {\n                const col = columnsByDataKey[ dataKey ];\n                const cellData = ( col.getCellData || getCellData )( row, i, dataKey );\n                return cellData.toString().includes( value );\n            });\n        });\n    }\n\n    @computed get grouped(){\n\n        const { group } = this.aggregators;\n\n        if( !group ){\n            return {\n                all: this.filtered\n            };\n        }\n\n        const { dataKey } = group;\n        const { columnsByDataKey, parent } = this;\n        const { getCellData, getRowData } = parent;\n\n        const col = columnsByDataKey[ dataKey ];\n\n        return groupBy( this.filtered, i => {\n            const row = getRowData( i );\n            const cellData = ( col.getCellData || getCellData )( row, i, dataKey );\n            return cellData;\n        });\n    }\n\n    @computed get sorted(){\n        const { columnsByDataKey, aggregators: { sort }, parent } = this;\n\n        if( sort ){\n            const { dataKey, value } = sort;\n            const { getCellData, getRowData } = parent;\n            const col = columnsByDataKey[ dataKey ];\n            const fn = col.getCellData || getCellData;\n            const sign = value === \"ascending\" ? 1 : -1;\n            return mapValues( this.grouped, v => v.sort(( a, b ) => {\n                const row1 = getRowData( a );\n                const row2 = getRowData( b );\n                const cell1 = fn( row1, a, dataKey );\n                const cell2 = fn( row2, b, dataKey );\n                if( cell1 > cell2 ){\n                    return sign;\n                }\n                if( cell1 < cell2 ){\n                    return -sign;\n                }\n                return 0;\n            }));\n        }\n        \n        return this.grouped;\n    }\n\n    @computed get flat(){\n        return reduce( this.sorted, ( result, groupArr, groupName ) => {\n            result.push( groupName, ...groupArr );\n            return result;\n        }, []);\n    }\n\n    @computed get visibleRowCount(){\n        return this.flat.length;\n    }\n}\n\nexport default RowsComplex;","import { observable, extendObservable, computed } from \"mobx\";\nimport add from \"lodash/add\";\nimport subtract from \"lodash/subtract\";\nimport RowsComplex from \"./RowsComplex\";\n\nconst OrderedRowsCache = Uint32Array;\nconst TbodyColumnWidthsCache = Uint32Array;\n\n/*\n    We could use simple object literal,\n    but constructors with stable-order this initialization enforce \"hidden-classes\" v8 optimization\n*/\nclass TotalsCachePart {\n    count = 0;\n    sum = 0;\n    average = 0.0;\n};\n\n/*\n    can't extend from both FixedSizeList and VariableSizeList, so exporting compositor\n*/\nconst createTable = BaseClass => class extends BaseClass {\n\n    Rows = new RowsComplex( this );\n\n    refreshTotalsForColumnRaw( dataKey, cellDataGetter ){\n        const curTotals = this.totals && this.totals[ dataKey ];\n        if( curTotals ){\n            let curCachePart = this.totalsCache[ dataKey ];\n\n            if( !curCachePart ){\n                curCachePart = this.totalsCache[ dataKey ] = new TotalsCachePart();\n            }\n            \n            for( let j = 0, totalType, oldVal, newVal, tmpSum; j < curTotals.length; j++ ){\n                totalType = curTotals[ j ];\n                oldVal = curCachePart[ totalType ];\n                switch( totalType ){\n                    case \"count\":\n                        newVal = this.rowCount;\n                        break;\n                    case \"sum\":\n                    case \"average\":\n                        if( tmpSum === undefined ){\n                            tmpSum = reduceRange( this.rowCount, dataKey, this.getRowData, cellDataGetter, 0, add );\n                        }\n                        newVal = totalType === \"sum\" ? tmpSum : tmpSum / this.rowCount;\n                        break;\n                    case \"min\":\n                    case \"max\":\n                        newVal = reduceRange(\n                            this.rowCount,\n                            dataKey,\n                            this.getRowData,\n                            cellDataGetter,\n                            totalType === \"min\" ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER,\n                            Math[totalType]\n                        );\n                        break;\n                    default:\n                        if( process.env.NODE_ENV !== \"production\" ){\n                            throw new Error( `Wrong total type: ${totalType}` );\n                        }\n                }\n  \n                if( oldVal !== newVal ){\n                    curCachePart[ totalType ] = newVal;\n                    this.emit( \"totals-calculated\" );\n                }\n            }\n        }\n        else if( process.env.NODE_ENV !== \"production\" ){\n            console.log( `Asked to recalculate totals for: ${dataKey}; doing nothing;` );\n        }\n        return this;\n    }\n\n    @computed get tbodyColumnWidthsSum(){\n        return this.tbodyColumnWidths.reduce( add );\n    }\n\n    constructor(){\n        super();\n\n        extendObservable( this, {\n            columns: [],\n            totals: {},\n            headlessMode: false,\n            getCellData: null,\n            tbodyColumnWidths: []\n        });\n    }\n\n    destructor(){\n        super.destructor();\n    }\n}\n\nexport default createTable;","import { extendObservable, computed, action, observable } from \"mobx\";\nimport clamp from \"lodash/clamp\";\n\nconst getRowDataInitial = () => {\n    throw new Error( \"getRowData must be provided\" );\n}\n\nconst BASIC_OBSERVABLE_FIELDS = {\n    rowCount: 0,\n    overscanRowsCount: 0,\n    estimatedRowHeightFallback: 0,\n\n    scrollLeft: 0,\n    scrollTop: 0,\n\n    widgetHeight: 0,\n    widgetWidth: 0,\n\n    getRowKey: undefined,\n    getRowData: getRowDataInitial,\n\n    rowsContainerNode: null,\n    scrollContainerNode: null\n};\n\nconst END_INDEX_CHECK_INTERVAL = 400;\n\nclass ScrollableRowsBase {\n\n    @computed get visibleRangeStart(){\n        return this.getVisibleRangeStart( this.scrollTop );\n    }\n\n    @computed get startIndex(){\n\n        if( !this.estimatedRowHeight ){\n            return 0;\n        }\n\n        const [ newVisibleStartIndex ] = this.visibleRangeStart;\n        return Math.max( 0, newVisibleStartIndex - this.overscanRowsCount );\n    }\n\n    @computed get endIndex(){\n\n        if( !this.estimatedRowHeight ){\n            return 0;\n        }\n        \n        const [ newEndIndex ] = this.getVisibleRangeStart( this.scrollTop + this.widgetHeight );\n\n        /*\n            getVisibleRangeStart works by \"strict less\" algo. It is good for startIndex,\n            but for endIndex we need \"<=\", so adding 1 artificially.\n        */\n        return Math.min( newEndIndex + 1 + this.overscanRowsCount, this.Rows.visibleRowCount );\n    }\n\n    @computed get virtualTopOffset(){\n        const [ newVisibleStartIndex, remainder ] = this.visibleRangeStart;\n        const overscanOffset = this.getDistanceBetweenIndexes( this.startIndex, newVisibleStartIndex );\n        return this.scrollTop - remainder - overscanOffset;\n    }\n    \n    @action\n    merge( params ){\n        Object.assign( this, params );\n    }\n    \n    constructor(){\n        \n        extendObservable( this, BASIC_OBSERVABLE_FIELDS, {\n            rowsContainerNode: observable.ref,\n            scrollContainerNode: observable.ref\n        });\n        /*\n        this\n            .on( \"#widgetScrollHeight\", this.increaseEndIndexIfNeeded )\n            .on( \"#endIndex\", this.increaseEndIndexIfNeeded.cancel );\n        */\n    }\n\n    \n\n    /*\n        Column heights may change during scroll/width-change\n    */\n \n /*   increaseEndIndexIfNeededSync(){\n        const currentVisibleDist = this.getDistanceBetweenIndexes( this.startIndex, this.endIndex );\n        if( this.widgetHeight > this.virtualTopOffset + currentVisibleDist - this.scrollTop ){\n            this.updateEndIndex();\n        }\n    }\n\n    increaseEndIndexIfNeeded = debounce( this.increaseEndIndexIfNeededSync, END_INDEX_CHECK_INTERVAL );\n*/\n    destructor(){\n       // this.increaseEndIndexIfNeeded.cancel();\n    }\n\n    scrollToRow( index ){\n        const node = this.scrollContainerNode;\n        if( node ){\n            node.scrollTop = this.getDistanceBetweenIndexes( 0, clamp( index, 0, this.Rows.visibleRowCount ) );\n        }\n        return this;    \n    }\n\n    scrollToStart(){\n        return this.scrollToRow( 0 );\n    }\n};\n\nexport default ScrollableRowsBase;","import createTable from \"./createTable\";\nimport FixedSizeScrollableRows from \"./FixedSizeScrollableRows\";\n\nexport default createTable( FixedSizeScrollableRows );","import { computed } from \"mobx\";\nimport ScrollableRowsBase from \"./ScrollableRowsBase\";\n\nclass FixedSizeScrollableRows extends ScrollableRowsBase {\n\n    @computed({ keepAlive: true }) get estimatedRowHeight(){\n        if( this.widgetWidth ){\n            const node = this.rowsContainerNode;\n\n            if( node ){\n                const { firstElementChild } = node;\n                if( firstElementChild ){\n                    return firstElementChild.offsetHeight;\n                }\n            }\n        }\n        return this.estimatedRowHeightFallback;\n    }\n\n    set estimatedRowHeight( value ){\n        this.estimatedRowHeightFallback = value;\n    }\n\n    @computed get widgetScrollHeight(){\n        return this.estimatedRowHeight * this.Rows.visibleRowCount;\n    }\n\n    getVisibleRangeStart( distance ){\n        const { estimatedRowHeight } = this;\n        return estimatedRowHeight ? [ distance / estimatedRowHeight | 0, distance % estimatedRowHeight ] : [ 0, 0 ];\n    }\n\n    getDistanceBetweenIndexes( startIndex, endIndex ){\n        return this.estimatedRowHeight * ( endIndex - startIndex );\n    }\n};\n\nexport default FixedSizeScrollableRows;","import { computed } from \"mobx\";\nimport groupBy from \"lodash/groupBy\";\nimport keyBy from \"lodash/keyBy\";\nimport times from \"lodash/times\";\n\nclass RowsSimple {\n\n    constructor( parent ){\n        this.parent = parent;\n    }\n\n    get visibleRowCount(){\n        return this.parent.rowCount;\n    }\n}\n\nexport default RowsSimple;","import createTable from \"./createTable\";\nimport VariableSizeList from \"./VariableSizeList\";\n\nexport default createTable( VariableSizeList );","import RowsSimple from \"./RowsSimple\";\n\nconst createList = BaseClass => class extends BaseClass {\n    Rows = new RowsSimple( this );\n};\n\nexport default createList;","import createList from \"./createList\";\nimport VariableSizeScrollableRows from \"./VariableSizeScrollableRows\";\n\nexport default createList( VariableSizeScrollableRows );","import ScrollableRowsBase from \"./ScrollableRowsBase\";\nimport { observable, extendObservable, computed, autorun, action, runInAction, reaction } from \"mobx\";\n\n/*\n    We should always have some extra space for new rows. We do not want to reallocate cache every time.\n*/\nconst MIN_TREE_CACHE_OFFSET = 15;\n\nconst ROW_MEASUREMENT_DEBOUNCE_INTERVAL = 200;\n\nclass VariableSizeScrollableRows extends ScrollableRowsBase {\n\n    rowsDomObserver = new MutationObserver(() => runInAction(() => {\n        this.lastRowsRenderTimeStamp = performance.now();\n    }));\n\n    disposeCallbacks = [];\n\n    @computed({ keepAlive: true }) get N(){\n        /* Nearest pow of 2 to visibleRowCount. 56 >= 64, 67 => 128, etc. */\n        const { visibleRowCount }  = this.Rows;\n        return visibleRowCount > 0 ? 2 << Math.log2( visibleRowCount + MIN_TREE_CACHE_OFFSET ) : 1;\n    }\n\n    @computed({ keepAlive: true }) get sTree(){\n        // Uint16 cannot be used here, because array stores intermediate sums, which can be huge.\n        return new Uint32Array( this.N << 1 );\n    }\n\n    calculateParentsInRange( startIndex, endIndex ){\n        const { sTree, N } = this;\n    \n        for( endIndex += N, startIndex += N; endIndex >>= 1; ){\n            for( let i = startIndex >>= 1; i <= endIndex; i++ ){\n                sTree[ i ] = sTree[ i << 1 ] + sTree[ i << 1 | 1 ];\n            }\n        }\n\n        /* In segments tree 1 node is always sum of all elements */\n        this.merge({ widgetScrollHeight: sTree[ 1 ] });\n    }\n   \n    getVisibleRangeStart( dist ){\n\n        const { widgetScrollHeight, estimatedRowHeight, sTree, N } = this;\n\n        if( widgetScrollHeight && estimatedRowHeight ){\n            let nodeIndex = 1, v;\n\n            while( nodeIndex < N ){\n                v = sTree[ nodeIndex <<= 1 ];\n                if( dist >= v ){\n                    dist -= v;\n                    nodeIndex |= 1;\n                }\n            }\n    \n            return [ nodeIndex - N, dist ];\n        }\n        \n        return [ 0, 0 ];\n    }\n\n    constructor(){\n        super();\n\n        extendObservable( this, {\n            estimatedRowHeight: 20,\n            widgetScrollHeight: 0,\n            lastRowsRenderTimeStamp: 0,\n        \n            /*\n                When all row heights are different,\n                we must \"predict\" them on the left of startIndex and on the right of endIndex(where they are invisible),\n                basing on what we know: heights between startIndex and endIndex.\n                Using simple average by default.\n            */\n            shouldResetInvisibleRowHeights: true\n        });\n\n        this.disposeCallbacks.push(\n            autorun(() => {\n\n                //superdirty\n                if( !this.rowCount ){\n                    return;\n                }\n                \n                const { sTree, estimatedRowHeight, N, Rows: { visibleRowCount } } = this;\n                sTree.fill( estimatedRowHeight, N, N + visibleRowCount );\n                if( estimatedRowHeight ){\n                    /*\n                        Trees are not always ideally allocated, gaps are possible.\n                        Classical way for calculating parents is much simpler,\n                        but can do much more work(summing zeros) in such conditions. Commented classic algo:\n                \n                        for( let i = N + visibleRowCount >> 1, j; i > 0; --i ){\n                            j = i << 1;\n                            sTree[ i ] = sTree[ j ] + sTree[ j | 1 ];\n                        }\n                    */\n                    this.calculateParentsInRange( 0, visibleRowCount );\n                }\n            }),\n            autorun(() => {\n                if( this.widgetWidth ){\n                    this.merge({\n                        shouldResetInvisibleRowHeights: true\n                    });\n                }\n            }),\n            autorun(() => {\n                this.rowsDomObserver.disconnect();\n                if( this.rowsContainerNode ){\n                    this.rowsDomObserver.observe( this.rowsContainerNode, { childList: true, subtree: true });\n                }\n            }),\n            reaction(\n                () => this.lastRowsRenderTimeStamp * this.widgetWidth,\n                () => {\n                    const node = this.rowsContainerNode;\n    \n                    if( node ){\n                        const { sTree, N } = this;\n                        \n                        let l = -1,\n                            r = -1,\n                            rowHeightsSum = 0,\n                            rowCounter = 0;\n            \n                        /*\n                            Some benchmarks inspire me to use nextElementSibling\n                            https://jsperf.com/nextsibling-vs-childnodes-increment/2\n                        */\n                        for( let child = node.firstElementChild, newHeight, index; child; child = child.nextElementSibling, rowCounter++ ){\n                            \n                            /*\n                                * aria-rowindex is counted from 1 according to w3c spec;\n                                * parseInt with radix is 2x faster, then +, -, etc.\n                                  https://jsperf.com/number-vs-parseint-vs-plus/116\n                            */\n                            index = parseInt( child.getAttribute( \"aria-rowindex\" ), 10 ) - 1;\n            \n                            if( process.env.NODE_ENV !== \"production\" && Number.isNaN( index ) ){\n                                throw new Error( \"aria-rowindex attribute must be present on each row. Look at default Row implementations.\" );\n                            }\n            \n                            newHeight = child.offsetHeight;\n                            rowHeightsSum += newHeight;\n            \n                            if( sTree[ N + index ] !== newHeight ){\n                                // console.log( \"%d| was: %d; is: %d\", index, sTree[N+index],newHeight)\n                                sTree[ N + index ] = newHeight;\n                                \n                                if( l === -1 ){\n                                    l = index;\n                                }\n                                \n                                r = index;\n                            }\n                        }\n             \n                        if( l !== -1 ){\n                            if( process.env.NODE_ENV !== \"production\" ){\n                                console.log( \"Updating heights in range: %d - %d\", l, r );\n                            }\n            \n                            if( this.shouldResetInvisibleRowHeights ){\n                                this.merge({\n                                    estimatedRowHeight: Math.round( rowHeightsSum / rowCounter ),\n                                    shouldResetInvisibleRowHeights: false\n                                });\n                            }\n                            else{\n                                this.calculateParentsInRange( l, r )\n                            }\n                        }\n                    }\n                },\n                { delay: ROW_MEASUREMENT_DEBOUNCE_INTERVAL }\n            )\n        );\n    }\n\n    destructor(){\n        this.disposeCallbacks.forEach( cb => cb() );\n        super.destructor();\n    }\n\n    getDistanceBetweenIndexes( startIndex, endIndex ){\n\n        if( !this.estimatedRowHeight ){\n            return 0;\n        }\n\n        const { sTree, N } = this;\n        let res = 0;\n\n        for( startIndex += N, endIndex += N; startIndex < endIndex; startIndex >>= 1, endIndex >>= 1 ){\n            if( startIndex & 1 ){\n                res += sTree[ startIndex++ ];\n            }\n\n            if( endIndex & 1 ){\n                res += sTree[ --endIndex ]; \n            }\n        };\n\n        return res; \n    }\n};\n\nexport default VariableSizeScrollableRows;","const getPropsGetter = propName => ( data, index, dataIndex, getExtraProps ) => {\n\n    /* avoiding double destructurization via getExtraProps, so making prop object once */\n    const props = {\n        [propName]: index + 1\n    };\n\n    if( getExtraProps ){\n        const extraProps = getExtraProps( data, index, dataIndex );\n        if( extraProps ){\n            if( process.env.NODE_ENV !== \"production\" ){\n                if( extraProps.hasOwnProperty( propName ) ){\n                    throw new Error( `getExtraProps must not override ${propName}` );\n                }\n            }\n            Object.assign( props, extraProps );\n        }\n    }\n\n    return props;\n}\n\nexport const getRowProps = getPropsGetter( \"aria-rowindex\" );\nexport const getCellProps = getPropsGetter( \"aria-colindex\" );","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getRowProps } from \"../../utils/extraPropsGetters\";\n\nconst Row = ({ columns, CellComponent, getRowData, getCellData, getRowExtraProps, getCellExtraProps, rowDataIndex, rowIndex }) => {\n\n    const rowData = getRowData( rowDataIndex );\n\n    return (\n        <tr {...getRowProps(rowData,rowIndex,rowDataIndex,getRowExtraProps)}>\n            {columns.map(( column, columnIndex ) => {\n                if( column.visibility === \"hidden\" ){\n                    return null;\n                }\n\n                const FinalCellComponent = column.CellComponent || CellComponent;\n\n                return (\n                    <FinalCellComponent\n                        key={column.dataKey}\n                        rowData={rowData}\n                        rowIndex={rowIndex}\n                        column={column}\n                        columnIndex={columnIndex}\n                        getCellData={getCellData}\n                        getCellExtraProps={column.getCellExtraProps||getCellExtraProps}\n                    />\n                );\n            })}\n        </tr>\n    );\n};\n\nRow.propTypes = {\n    getCellData: PropTypes.func.isRequired,\n    columns: PropTypes.array.isRequired,\n    CellComponent: PropTypes.elementType.isRequired,\n    getRowData: PropTypes.func.isRequired,\n    rowIndex: PropTypes.number.isRequired,\n    rowDataIndex: PropTypes.number.isRequired,\n    getRowExtraProps: PropTypes.func,\n    getCellExtraProps: PropTypes.func\n};\n\nexport default Row;","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getCellProps } from \"../../utils/extraPropsGetters\";\n\n/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/\nconst DEFAULT_EMPTY_CELL_CONTENT = \"\\u00A0\";\n\nconst Cell = ({ rowData, rowIndex, getCellData: getCellDataDefault, column, columnIndex, getCellExtraProps }) => {\n    const { render, getEmptyCellData, dataKey, format, getCellData } = column;\n\n    let cellData = rowData && ( getCellData || getCellDataDefault )( rowData, rowIndex, dataKey );\n    \n    if( cellData === undefined || cellData === \"\" ){\n        cellData = getEmptyCellData ? getEmptyCellData( rowIndex, column ) : DEFAULT_EMPTY_CELL_CONTENT;\n    }\n    else{\n        if( format ){\n            cellData = format( cellData, rowData );\n        }\n        if( render ){\n            cellData = render( cellData, rowData, column );\n        }\n    }\n\n    return (\n        <td {...getCellProps(rowData,columnIndex,columnIndex,getCellExtraProps)}>\n            {cellData}\n        </td>\n    );\n};\n\nCell.propTypes = {\n    getCellData: PropTypes.func.isRequired,\n    rowIndex: PropTypes.number.isRequired,\n    columnIndex: PropTypes.number.isRequired,\n    column: PropTypes.object.isRequired,\n    rowData: PropTypes.object,\n    getCellExtraProps: PropTypes.func\n};\n\nexport default Cell;","import React, { Fragment } from \"react\";\nimport { observer } from \"mobx-react-lite\";\n\nconst Total = observer(({ cache, showSummaryType, summaryType, formatTotal }) => {\n    const res = cache[ summaryType ];\n\n    return res !== undefined ? (\n        <div key={summaryType} title={summaryType} className=\"afvscr-summary\">\n            {showSummaryType ? (\n                <Fragment>{summaryType}&nbsp;</Fragment>\n            ) : null}\n            {formatTotal?formatTotal(res):res}\n        </div>\n    ) : null;\n});\n\nconst TotalsCell = ({ cellTotals, totalsCache, formatTotal }) => {\n\n    if( !cellTotals || !totalsCache ){\n        return null;\n    }\n\n    if( cellTotals.length === 1 ){\n        return (\n            <Total\n                summaryType={cellTotals[0]}\n                cache={totalsCache}\n                formatTotal={formatTotal}\n            />\n        );\n    }\n\n    return cellTotals.map( summaryType => (\n        <Total\n            showSummaryType\n            summaryType={summaryType}\n            cache={totalsCache}\n            formatTotal={formatTotal}\n        />\n    ));\n};\n\nexport default observer( TotalsCell );","const cx = ( baseClass, extraClass ) => extraClass ? `${baseClass} ${extraClass}` : baseClass;\n\nexport default cx;","import React from \"react\";\nimport cx from \"../utils/cx\"\n\nconst RowCountWarningContainer = ({ className, ...props }) => <div className={cx(\"afvscr-row-count-warning-container\",className)} {...props} />;\n\nexport default RowCountWarningContainer;","import { useContext } from \"react\";\nimport Context from \"../Context\";\n\nconst useApi = () => useContext( Context );\n\nexport default useApi;\n","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport useApi from \"../../useApi\";\n\nconst Colgroup = ({ useTbodyWidths }) => {\n\n    const { columns, tbodyColumnWidths } = useApi();\n\n    return (\n        <colgroup>\n            {columns.map(({ dataKey, background, visibility, border, width }, j ) => visibility !== \"hidden\" ? (\n                <col\n                    key={dataKey}\n                    style={{\n                        width: useTbodyWidths ? tbodyColumnWidths[ j ] : width,\n                        background,\n                        border\n                    }}\n                />\n            ) : null )}\n        </colgroup>\n    );\n};\n\nexport default observer( Colgroup );","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport useApi from \"../../../useApi\";\nimport Colgroup from \"../../common/Colgroup\";\nimport cx from \"../../../utils/cx\";\n\nconst TableWrapper = ({ children, className, ...props }) => {\n\n    const { scrollLeft, columns, tbodyColumnWidthsSum } = useApi();\n\n    const style = {\n        /* If we do this via transform translate, col background would have bugs during horizontal scroll. Strange webkit behavior */\n        marginLeft: -scrollLeft,\n        width: tbodyColumnWidthsSum\n    };\n\n    return (\n        <table className={cx(\"afvscr-nonst-subtable\",className)} {...props} style={style} aria-colcount={columns.length}>\n            <Colgroup useTbodyWidths />\n            {children}\n        </table>\n    );\n};\n\nexport default observer( TableWrapper );","import React from \"react\";\nimport useApi from \"../../useApi\";\nimport { observer } from \"mobx-react-lite\";\n\nconst HeaderCells = () => {\n\n    const { columns, Rows } = useApi();\n    const { sort } = Rows.aggregators;\n\n    return columns.map(({ dataKey, title, sort: colSort, label, visibility }, j ) => visibility === \"hidden\" ? null : (\n        <th\n            key={dataKey}\n            title={title}\n            data-sortable={colSort?\"\":undefined}\n            aria-colindex={j+1}\n            aria-sort={sort&&sort.dataKey === dataKey?sort.value:\"none\"}\n        >\n            {label}\n        </th>\n    ));\n};\n\nexport default observer( HeaderCells );","import React, { useCallback, memo } from \"react\";\nimport HeaderCells from \"./HeaderCells\";\nimport useApi from \"../../useApi\";\n\nconst Thead = ({ trRef, getCellStyle, ...props }) => {\n\n    const API = useApi();\n\n    const clickHandler = useCallback( e => {\n\n        const colIndex = parseInt( e.target.getAttribute( \"aria-colindex\" ), 10 ) - 1;\n\n        if( process.env.NODE_ENV !== \"production\" && Number.isNaN( colIndex ) ){\n            throw new Error( \"colIndex attr missing\" );\n        }\n\n        const { sort, dataKey } = API.columns[ colIndex ];\n\n        if( e.ctrlKey ){\n            API.Rows.modifyAggregators({\n                group: API.Rows.aggregators.group && API.Rows.aggregators.group.dataKey === dataKey ? null : {\n                    dataKey,\n                    value: \"\"\n                }\n            });\n        }\n        else if( sort ){\n            const value = e.target.getAttribute( \"aria-sort\" ) === \"ascending\" ? \"descending\" : \"ascending\";\n            API.Rows.modifyAggregators({\n                sort: {\n                    dataKey,\n                    value\n                }\n            });\n        }\n    }, []);\n\n    return (\n        <thead {...props} onClick={clickHandler}>\n            <tr ref={trRef}>\n                <HeaderCells />\n            </tr>\n        </thead>\n    );\n};\n\nexport default memo( Thead );","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport PropTypes from \"prop-types\";\nimport useApi from \"../../useApi\";\n\nconst FooterCells = ({ TotalsCellComponent }) => {\n\n    const { columns, totals, Rows: { totalsCache } } = useApi();\n\n    return columns.map(({ dataKey, formatTotal, visibility }, j ) => {\n\n        if( visibility === \"hidden\" ){\n            return null;\n        }\n\n        const curTotals = totals[ dataKey ];\n        const curTotalsCache = totalsCache[ dataKey ];\n\n        return (\n            <td key={dataKey} aria-colindex={j+1}>\n                <TotalsCellComponent\n                    cellTotals={curTotals}\n                    totalsCache={curTotalsCache}\n                    formatTotal={formatTotal}\n                />\n            </td>\n        );\n    });\n};\n\nFooterCells.propTypes = {\n    TotalsCellComponent: PropTypes.elementType.isRequired\n}\n\nexport default observer( FooterCells );","import React, { memo } from \"react\";\nimport FooterCells from \"./FooterCells\";\n\nconst Tfoot = ({ className, trRef, TotalsCellComponent }) => (\n    <tfoot className={className}>\n        <tr ref={trRef}>\n            <FooterCells TotalsCellComponent={TotalsCellComponent} />\n        </tr>\n    </tfoot>\n);\n\nexport default memo( Tfoot );","import React, { memo } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getRowProps } from \"../../utils/extraPropsGetters\";\n\nconst GroupRow = ({ columns, groupKey, rowIndex }) => (\n    <tr {...getRowProps(null,rowIndex)}>\n        <td colSpan={columns.length} className=\"afvscr-group-cell\">\n            {groupKey}\n        </td>\n    </tr>\n);\n\nGroupRow.propTypes = {\n    columns: PropTypes.array.isRequired,\n    rowIndex: PropTypes.number.isRequired,\n    groupKey: PropTypes.string.isRequired\n};\n\nexport default memo( GroupRow );","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport useApi from \"../../useApi\";\nimport GroupRow from \"./GroupRow\";\n\nconst getVisibleRows = (\n    orderedRows,\n    rangeFrom,\n    rangeTo,\n    columns,\n    getRowData,\n    getCellData,\n    getRowKey,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent\n) => {\n    const result = [];\n    for( let rowKey, idx; rangeFrom < rangeTo; rangeFrom++ ){\n        idx = orderedRows[ rangeFrom ];\n\n        if( typeof idx === \"number\" ){\n            rowKey = getRowKey ? getRowKey( idx ) : idx;\n            result.push(\n                <RowComponent\n                    getRowExtraProps={getRowExtraProps}\n                    getCellExtraProps={getCellExtraProps}\n                    rowIndex={rangeFrom}\n                    rowDataIndex={idx}\n                    key={rowKey}\n                    columns={columns}\n                    getRowData={getRowData}\n                    getCellData={getCellData}\n                    CellComponent={CellComponent}\n                />\n            );\n        }\n        else {\n            result.push(\n                <GroupRow\n                    key={`group_${idx}`}\n                    groupKey={idx}\n                    columns={columns}\n                    rowIndex={rangeFrom}\n                />\n            );\n        }\n    }\n    return result;\n};\n\nconst Rows = ({ getRowExtraProps, getCellExtraProps, RowComponent, CellComponent }) => {\n\n    const API = useApi();\n\n    return getVisibleRows(\n        API.Rows.flat,\n        API.startIndex,\n        API.endIndex,\n        API.columns,\n        API.getRowData,\n        API.getCellData,\n        API.getRowKey,\n        getRowExtraProps,\n        getCellExtraProps,\n        RowComponent,\n        CellComponent\n    );\n};\n\nexport default observer( Rows );","import React, { memo } from \"react\";\nimport Rows from \"./Rows\";\n\nconst Tbody = ({\n    getRowExtraProps,\n    getCellExtraProps,\n    tbodyRef,\n    RowComponent,\n    CellComponent\n}) => (\n    <tbody ref={tbodyRef}>\n        <Rows\n            getRowExtraProps={getRowExtraProps}\n            getCellExtraProps={getCellExtraProps}\n            RowComponent={RowComponent}\n            CellComponent={CellComponent}\n        />\n    </tbody>\n);\n\nexport default memo( Tbody );","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport useApi from \"../../useApi\";\n\nconst BodyTable = ({ children }) => {\n\n    const API = useApi();\n\n    return (\n        <table\n            children={children}\n            className=\"afvscr-main-table\"\n            aria-rowcount={API.rowCount}\n            aria-colcount={API.columns.length}\n        />\n    );\n};\n\nexport default observer( BodyTable );","import { useRef, useEffect, useCallback } from \"react\";\n\nconst useColWidthsResizeObserver = API => {\n\n    const observerRef = useRef();\n    const mutationObserverRef = useRef();\n\n    let RO = observerRef.current;\n    let MO = mutationObserverRef.current;\n\n    if( !RO ){\n        RO = observerRef.current = new ResizeObserver( entries => {\n            for( let j = 0, colIndex; j < entries.length; j++ ){\n                const { target } = entries[ j ];\n                colIndex = parseInt( target.getAttribute( \"aria-colindex\" ) );\n\n                /*\n                    using target.offsetWidth instead of contentRect.width, because we need border-box sizing, \n                    and { box: border-box } option does not work here\n                */\n                API.tbodyColumnWidths[ colIndex - 1 ] = Math.round( target.offsetWidth );\n            }\n        });\n\n        MO = mutationObserverRef.current = new MutationObserver( entries => {\n            for( let i = 0; i < entries.length; i++ ){\n                const { addedNodes, removedNodes } = entries[ i ];\n                for( let j = 0; j < addedNodes.length; j++ ){\n                    RO.observe( addedNodes[ j ] );\n                }\n                for( let j = 0; j < removedNodes.length; j++ ){\n                    RO.unobserve( removedNodes[ j ] );\n                }\n            }   \n        });\n    }\n\n    useEffect(() => () => {\n        RO.disconnect();\n        MO.disconnect();\n    }, []);\n\n    /* callback ref */\n    return useCallback( trNode => {\n        MO.disconnect();\n        RO.disconnect();\n        if( trNode ){\n            MO.observe( trNode, { childList: true });\n        }\n    }, []);\n};\n\nexport default useColWidthsResizeObserver;","import React from \"react\";\nimport useApi from \"../useApi\";\nimport { observer } from \"mobx-react-lite\";\n\nconst Scroller = ({ Component }) => {\n\n    const { virtualTopOffset } = useApi();\n\n    /*\n        Hmm, I can't put here more than ~ 3 000 000. Maybe need to put one more row in case this height is > 3 000 000\n    */\n    return <Component className=\"afvscr-scroller\" aria-hidden=\"true\" style={{ height: virtualTopOffset }} />;\n};\n\nexport default observer( Scroller );","import React from \"react\";\nimport Scroller from \"../../common/Scroller\";\n\n/*\n    According to specs, tr must always be inside tbody, thead or tfoot                \n*/\nconst TbodyScroller = () => (\n    <tbody className=\"afvscr-scroller\" aria-hidden=\"true\">\n        <Scroller Component=\"tr\" />\n    </tbody>\n);\n\nexport default TbodyScroller;","import React, { cloneElement } from \"react\";\nimport useApi from \"../useApi\";\nimport { observer } from \"mobx-react-lite\";\n\nconst el = <div aria-hidden=\"true\" className=\"afvscr-height-provider\" />;\n\nconst HeightProvider = () => cloneElement( el, {\n    style: {\n        height: useApi().widgetScrollHeight\n    }\n});\n\nexport default observer( HeightProvider );","import React, { forwardRef, useCallback, useEffect } from \"react\";\nimport cx from \"../utils/cx\";\nimport HeightProvider from \"./HeightProvider\";\nimport useApi from \"../useApi\";\n\nconst ScrollContainer = forwardRef(({\n    className,\n    children,\n    onScroll,\n    ...props\n}, ref ) => {\n\n    const API = useApi();\n\n    const scrollHandler = useCallback( e => {\n        const { scrollTop, scrollLeft } = e.target;\n        API.merge({\n            scrollLeft,\n            scrollTop\n        });\n        if( onScroll ){\n            onScroll( e );\n        }\n    }, [ onScroll ]);\n\n    useEffect(() => {\n        const el = ref.current;\n\n        const R = new ResizeObserver( entries => {\n            if( entries.length === 1 ){\n                /*\n                    using target.offsetWidth instead of contentRect.width, because we need border-box sizing, \n                    and { box: border-box } option does not work here\n                */\n                const { offsetWidth, offsetHeight } = entries[ 0 ].target;\n\n                API.merge({\n                    widgetHeight: Math.round( offsetHeight ),\n                    widgetWidth: Math.round( offsetWidth )\n                });\n            }\n        });\n\n        R.observe( el );\n\n        return () => {\n            R.unobserve( el );\n        };\n    }, []);\n    \n    /*\n        tabIndex=\"0\" is for proper keyboard nav\n        https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\n    */\n    return (\n        <div tabIndex=\"0\" className={cx(\"afvscr-scroll-container\",className)} ref={ref} onScroll={scrollHandler} {...props}>\n            <HeightProvider />\n            {children}\n        </div>\n    );\n});\n\nexport default ScrollContainer;","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport PropTypes from \"prop-types\";\n\nimport useApi from \"../../useApi\";\nimport TableWrapper from \"./TableWrapper\";\n\nimport Thead from \"../common/Thead\";\nimport Tfoot from \"../common/Tfoot\";\nimport Tbody from \"../common/Tbody\";\nimport BodyTable from \"../common/BodyTable\";\n\nimport useColWidthsResizeObserver from \"./useColWidthsResizeObserver\";\nimport Colgroup from \"../common/Colgroup\";\nimport TbodyScroller from \"../common/TbodyScroller\";\nimport ScrollContainer from \"../../common/ScrollContainer\";\nimport cx from \"../../utils/cx\";\n\nconst NonSticky = ({\n    className,\n    tbodyRef,\n    scrollContainerRef,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent,\n    TotalsCellComponent,\n    onScroll,\n    ...props\n}) => {\n\n    const API = useApi();\n\n    const { headlessMode, totals } = API;\n\n    /*\n        Hidden tfoot & thead are needed to 'hold' widths of tbody columns no to be narrower than real thead/tfoot\n        and notify model about columns width changes.\n        There are 3 tables rendered in this mode, so their column widths need to be synced somehow.\n    */\n    const widthsObserverRef = useColWidthsResizeObserver( API );\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        if( headlessMode && !totals ){\n            console.warn( \"NonSticky table is rendered without headers and footers. This is not ok.\" )\n        }\n    }\n\n    return (\n        <div className={cx(\"afvscr-nonst\",className)} {...props}>\n            {headlessMode ? null : (\n                <TableWrapper>\n                    <Thead />\n                </TableWrapper>\n            )}\n            <ScrollContainer ref={scrollContainerRef} onScroll={onScroll}>\n                <BodyTable>\n                    <Colgroup />\n                    {headlessMode ? null : (\n                        <Thead\n                            className=\"afvscr-hdnwrp\"\n                            trRef={widthsObserverRef}\n                        />\n                    )}\n                    {totals && (\n                        <Tfoot\n                            TotalsCellComponent={TotalsCellComponent}\n                            className=\"afvscr-hdnwrp\"\n                            trRef={headlessMode?widthsObserverRef:undefined}\n                        />\n                    )}\n                    <TbodyScroller />\n                    <Tbody\n                        tbodyRef={tbodyRef}\n                        getRowExtraProps={getRowExtraProps}\n                        getCellExtraProps={getCellExtraProps}\n                        RowComponent={RowComponent}\n                        CellComponent={CellComponent}\n                    />\n                </BodyTable>\n            </ScrollContainer>\n            {totals && (\n                <TableWrapper>\n                    <Tfoot TotalsCellComponent={TotalsCellComponent} />\n                </TableWrapper>\n            )}\n        </div>\n    );\n};\n\nexport default observer( NonSticky );","import React, { useEffect } from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport Colgroup from \"../common/Colgroup\";\nimport TbodyScroller from \"../common/TbodyScroller\";\nimport ScrollContainer from \"../../common/ScrollContainer\";\nimport Thead from \"../common/Thead\";\nimport Tbody from \"../common/Tbody\";\nimport Tfoot from \"../common/Tfoot\";\nimport BodyTable from \"../common/BodyTable\";\nimport useApi from \"../../useApi\";\nimport cx from \"../../utils/cx\";\n\n\n/*\n    Todo:\n        measure thead & tfoot heights in order to properly calculate available space for rows\n*/\n\n\nconst Sticky = ({\n    tbodyRef,\n    scrollContainerRef,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent,\n    TotalsCellComponent,\n    className,\n    ...props\n}) => {\n\n    const { headlessMode, totals } = useApi();\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        /*\n            https://bugs.chromium.org/p/chromium/issues/detail?id=702927\n        */\n\n        const areTotalsPresent = totals && totals.length !== 0;\n\n        useEffect(() => {\n            if( !headlessMode || areTotalsPresent ){\n                /* TODO: tests fail without this if */\n                if( scrollContainerRef.current ){\n                    const table = scrollContainerRef.current.querySelector( \"table\" );\n                    const tableStyle = getComputedStyle( table );\n    \n                    if( tableStyle.borderCollapse === \"collapse\" ){\n                        console.warn(\n                            \"You use sticky table version. Due to special border behavior when scrolling, use border-collpase: separate.%o\",\n                            \"https://bugs.chromium.org/p/chromium/issues/detail?id=702927\"\n                        );\n                    }\n                }\n            }\n        }, [ headlessMode, areTotalsPresent ]);\n    }\n    \n    return (\n        <ScrollContainer ref={scrollContainerRef} className={cx(\"afvscr-st\",className)} {...props}>\n            <BodyTable>\n                <Colgroup />\n                {headlessMode?null:<Thead />}\n                <TbodyScroller />\n                <Tbody\n                    tbodyRef={tbodyRef}\n                    getRowExtraProps={getRowExtraProps}\n                    getCellExtraProps={getCellExtraProps}\n                    RowComponent={RowComponent}\n                    CellComponent={CellComponent}\n                />\n                {totals && (\n                    <Tfoot TotalsCellComponent={TotalsCellComponent} />\n                )}\n            </BodyTable>\n        </ScrollContainer>\n    );\n}\n\nexport default observer( Sticky );","const commonDefaultProps = {\n    fixedSize: false,\n    rowCount: 0,\n    overscanRowsCount: 4,\n    estimatedRowHeight: 16\n};\n\nexport default commonDefaultProps;","import React, { memo } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport isPositionStickySupported from \"../utils/isPositionStickySupported\";\nimport Context from \"../Context\";\nimport useStore from \"../utils/useStore\";\n\nimport FixedSizeTableStore from \"../models/FixedSizeTable\";\nimport VariableSizeTableStore from \"../models/VariableSizeTable\";\n\nimport RowComponentDefault from \"./common/Row\";\nimport CellComponentDefault from \"./common/Cell\";\nimport TotalsCellComponentDefault from \"./common/TotalsCell\";\n\nimport RowCountWarningContainerDefault from \"../common/RowCountWarningContainer\";\n\nimport NonStickyComponent from \"./NonSticky\";\nimport StickyComponent from \"./Sticky\";\n\nimport commonPropTypes from \"../commonPropTypes\";\nimport commonDefaultProps from \"../commonDefaultProps\";\nimport cx from \"../utils/cx\";\n\nconst Table = ({\n    fixedSize,\n    estimatedRowHeight,\n    columns,\n    totals,\n    getRowData,\n    getCellData,\n    getRowKey,\n    getRowExtraProps,\n    getCellExtraProps,\n    rowCount,\n    overscanRowsCount,\n    rowCountWarningsTable,\n    headless,\n    RowCountWarningContainer,\n    dataRef,\n    nonSticky,\n    className,\n    ...props\n}) => {\n\n    const [ Store, scrollContainerRef, tbodyRef ] = useStore( fixedSize ? FixedSizeTableStore : VariableSizeTableStore, dataRef, {\n        headlessMode: headless,\n        getRowData,\n        getCellData,\n        getRowKey,\n        overscanRowsCount,\n        estimatedRowHeight,\n        totals,\n        columns,\n        rowCount\n    });\n\n    /*\n        Only cells inside thead/tfoot can be sticky.\n        If thead/tfoot are hidden - we can easily render lighter StickyComponent to avoid extra wrappers\n    */\n    const ComponentVariant = ( headless && !totals ) || ( !nonSticky && isPositionStickySupported() ) ? StickyComponent : NonStickyComponent;\n\n    return (\n        <Context.Provider value={Store}>\n            { rowCount > 0 ? (\n                <ComponentVariant\n                    className={cx(\"afvscr-table-wrapper\",className)}\n                    scrollContainerRef={scrollContainerRef}\n                    getRowExtraProps={getRowExtraProps}\n                    getCellExtraProps={getCellExtraProps}\n                    tbodyRef={tbodyRef}\n                    {...props}\n                />\n            ) : rowCountWarningsTable ? (\n                <RowCountWarningContainer>\n                    {rowCountWarningsTable[rowCount]}\n                </RowCountWarningContainer>\n            ) : null }\n        </Context.Provider>\n    );\n}\n\nTable.propTypes = {\n    ...commonPropTypes,\n    columns: PropTypes.arrayOf(\n        PropTypes.shape({\n            // unique key for column\n            dataKey: PropTypes.string.isRequired,\n\n            // for details see CellComponent implementation\n            getCellData: PropTypes.func,\n            getEmptyCellData: PropTypes.func,\n            format: PropTypes.func,\n            render: PropTypes.func,\n            formatTotal: PropTypes.func,\n\n            visibility: PropTypes.oneOf([ \"visible\", \"hidden\" ]),\n            sort: PropTypes.oneOf([ \"locale\", \"numeric\" ]),\n\n            // column props, affecting colgroup > col tags\n            background: PropTypes.string,\n            border: PropTypes.string,\n            width: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\n            CellComponent: PropTypes.elementType,\n            getCellExtraProps: PropTypes.func\n        })\n    ).isRequired,\n\n    getCellExtraProps: PropTypes.func,\n\n    totals: PropTypes.objectOf(\n        // array may contain: \"sum\", \"average\", \"count\", \"max\", \"min\"\n        PropTypes.array\n    ),\n    \n    nonSticky: PropTypes.bool,\n    headless: PropTypes.bool,\n\n    HeaderRowComponent: PropTypes.elementType,\n    CellComponent: PropTypes.elementType,\n    getCellData: PropTypes.func,\n    TotalsCellComponent: PropTypes.elementType,\n\n    RowCountWarningContainer: PropTypes.elementType,\n    rowCountWarningsTable: PropTypes.object\n};\n\nTable.defaultProps = {\n    ...commonDefaultProps,\n    headless: false,\n\n    //    For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.\n    //    If RowComponent should be wrapped my mobx observer - non-memo version should be imported.\n    //    memo(observer(RowComponentDefault)) will do the trick.\n    \n    RowComponent: memo( RowComponentDefault ),\n    CellComponent: CellComponentDefault,\n    getCellData: ( rowData, rowIndex, dataKey ) => rowData[ dataKey ],\n    TotalsCellComponent: TotalsCellComponentDefault,\n    RowCountWarningContainer: RowCountWarningContainerDefault,\n};\n\nexport default memo( Table );","import React from \"react\";\nimport Table from \"af-virtual-scroll/src/Table\";\n\nconst columns = [\n    {\n        dataKey: \"a\",\n        label: \"a\"\n    },\n    {\n        dataKey: \"b\",\n        label: \"b\"\n    },\n    {\n        dataKey: \"c\",\n        label: \"c\"\n    }\n];\n\nconst getRowData = index => ({\n    a: index,\n    b: `cell_b_row: ${index}`,\n    c: `cell_c_row: ${index}`\n})\n\nconst SimpleTable = ({ className }) => (\n    <Table\n        className={className}\n        getRowData={getRowData}\n        rowCount={500}\n        columns={columns}\n        estimatedRowHeight={200}\n    />\n);\n\nexport default SimpleTable;"],"sourceRoot":""}