{"version":3,"sources":["webpack:///./src/utils/isPositionStickySupported/index.js","webpack:///./src/Context.js","webpack:///./src/utils/useStore/index.js","webpack:///./src/models/RowsComplex.js","webpack:///./src/models/createTable.js","webpack:///./src/models/ScrollableRowsBase.js","webpack:///./src/models/FixedSizeTable.js","webpack:///./src/models/FixedSizeScrollableRows.js","webpack:///./src/models/RowsSimple.js","webpack:///./src/models/VariableSizeTable.js","webpack:///./src/models/createList.js","webpack:///./src/models/VariableSizeList.js","webpack:///./src/models/VariableSizeScrollableRows.js","webpack:///./src/utils/extraPropsGetters/index.js","webpack:///./src/Table/common/Row.js","webpack:///./src/Table/common/Cell.js","webpack:///./src/Table/common/TotalsCell.js","webpack:///./src/utils/cx/index.js","webpack:///./src/common/RowCountWarningContainer.js","webpack:///./src/useApi/index.js","webpack:///./src/Table/common/Colgroup.js","webpack:///./src/Table/NonSticky/TableWrapper/index.js","webpack:///./src/Table/common/HeaderCells.js","webpack:///./src/Table/common/Thead.js","webpack:///./src/Table/common/FooterCells.js","webpack:///./src/Table/common/Tfoot.js","webpack:///./src/Table/common/GroupRow.js","webpack:///./src/Table/common/Rows.js","webpack:///./src/Table/common/Tbody.js","webpack:///./src/Table/common/BodyTable.js","webpack:///./src/Table/NonSticky/useColWidthsResizeObserver/index.js","webpack:///./src/common/Scroller.js","webpack:///./src/Table/common/TbodyScroller.js","webpack:///./src/common/HeightProvider.js","webpack:///./src/common/ScrollContainer.js","webpack:///./src/Table/NonSticky/index.js","webpack:///./src/Table/Sticky/index.js","webpack:///./src/commonDefaultProps.js","webpack:///./src/Table/index.js","webpack:///./websiteSrc/examples/table/simple.js"],"names":["elStyle","document","createElement","style","cssText","map","p","join","isSupported","position","includes","isPositionStickySupported","createContext","useStore","StoreConstructor","dataRef","propsToMerge","scrollContainerRef","useRef","rowsContainerRef","finalDataRef","Store","current","useEffect","merge","rowsContainerNode","scrollContainerNode","destructor","TotalsCachePart","rows","dataKey","this","parent","rowCount","res","columnsByDataKey","col","getCellData","getRowData","fn","i","sum","count","computed","RowsComplex","modifyAggregators","arg","Object","assign","aggregators","mapValues","totals","v","k","keyBy","columns","times","filter","length","rowIndexesArray","row","every","value","type","toString","group","all","filtered","groupBy","sort","sign","grouped","a","b","row1","row2","cell1","cell2","reduce","sorted","result","groupArr","groupName","push","flat","observable","action","createTable","BaseClass","Rows","extendObservable","headlessMode","tbodyColumnWidths","add","BASIC_OBSERVABLE_FIELDS","overscanRowsCount","estimatedRowHeightFallback","scrollLeft","scrollTop","widgetHeight","widgetWidth","getRowKey","undefined","Error","ScrollableRowsBase","ref","params","getVisibleRangeStart","estimatedRowHeight","newVisibleStartIndex","visibleRangeStart","Math","max","newEndIndex","min","visibleRowCount","remainder","overscanOffset","getDistanceBetweenIndexes","startIndex","scrollToRow","index","node","clamp","scrollToStart","keepAlive","distance","endIndex","firstElementChild","offsetHeight","RowsSimple","createList","rowsDomObserver","MutationObserver","runInAction","lastRowsRenderTimeStamp","performance","now","disposeCallbacks","widgetScrollHeight","shouldResetInvisibleRowHeights","autorun","sTree","N","fill","calculateParentsInRange","disconnect","observe","childList","subtree","reaction","newHeight","l","r","rowHeightsSum","rowCounter","child","nextElementSibling","parseInt","getAttribute","round","delay","dist","nodeIndex","log2","Uint32Array","forEach","cb","getPropsGetter","propName","data","dataIndex","getExtraProps","props","extraProps","getRowProps","getCellProps","Row","CellComponent","getRowExtraProps","getCellExtraProps","rowDataIndex","rowIndex","rowData","column","columnIndex","visibility","FinalCellComponent","key","propTypes","Cell","getCellDataDefault","render","getEmptyCellData","format","cellData","Total","observer","cache","showSummaryType","summaryType","formatTotal","title","className","TotalsCell","cellTotals","totalsCache","cx","baseClass","extraClass","RowCountWarningContainer","useApi","useContext","Context","Colgroup","useTbodyWidths","j","background","border","width","TableWrapper","children","marginLeft","tbodyColumnWidthsSum","aria-colcount","HeaderCells","colSort","label","data-sortable","aria-colindex","aria-sort","Thead","trRef","getCellStyle","API","clickHandler","useCallback","e","colIndex","target","ctrlKey","onClick","memo","FooterCells","TotalsCellComponent","curTotals","curTotalsCache","Tfoot","GroupRow","groupKey","colSpan","RowComponent","orderedRows","rangeFrom","rangeTo","rowKey","idx","getVisibleRows","Tbody","tbodyRef","BodyTable","aria-rowcount","useColWidthsResizeObserver","observerRef","mutationObserverRef","RO","MO","ResizeObserver","entries","offsetWidth","addedNodes","removedNodes","unobserve","trNode","Scroller","Component","virtualTopOffset","aria-hidden","height","TbodyScroller","el","HeightProvider","cloneElement","ScrollContainer","forwardRef","onScroll","scrollHandler","R","tabIndex","NonSticky","widthsObserverRef","Sticky","commonDefaultProps","fixedSize","Table","rowCountWarningsTable","headless","nonSticky","FixedSizeTableStore","VariableSizeTableStore","ComponentVariant","StickyComponent","NonStickyComponent","Provider","defaultProps","RowComponentDefault","CellComponentDefault","TotalsCellComponentDefault","RowCountWarningContainerDefault","c","SimpleTable"],"mappings":"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","file":"23.2c7a20dd80d72ac644f1.js","sourcesContent":["const elStyle = document.createElement( \"a\" ).style;\nelStyle.cssText = [ \"\", \"-webkit-\", \"-ms-\" ].map( p => `position:${p}sticky` ).join( \";\" );\n\nconst isSupported = elStyle.position.includes( \"sticky\" );\n\nconst isPositionStickySupported = () => isSupported;\n\nexport default isPositionStickySupported;","import { createContext } from \"react\";\n\nexport default createContext();","import { useRef, useEffect } from \"react\";\n\n/*\n    dataRef is to call Data methods from outside( Data.scrollTo(), etc. ).\n    As it is not dom-related, I decided to avoid forwardRef\n*/\nconst useStore = ( StoreConstructor, dataRef, propsToMerge ) => {\n\n    const scrollContainerRef = useRef();\n    const rowsContainerRef = useRef();\n\n    const finalDataRef = useRef();\n\n    let Store = finalDataRef.current;\n\n    if( !Store || !( Store instanceof StoreConstructor ) ){\n        Store = finalDataRef.current = new StoreConstructor();\n    }\n\n    if( dataRef ){\n        dataRef.current = Store;\n    }\n\n    useEffect(() => {\n        Store.merge({\n            ...propsToMerge,\n            rowsContainerNode: rowsContainerRef.current,\n            scrollContainerNode: scrollContainerRef.current\n        });\n    });\n\n    useEffect(() => () => {\n        Store.destructor();\n    }, [ Store ]);\n\n    return [ Store, scrollContainerRef, rowsContainerRef ];\n};\n\nexport default useStore;","import { computed, action, observable } from \"mobx\";\nimport groupBy from \"lodash/groupBy\";\nimport mapValues from \"lodash/mapValues\";\nimport keyBy from \"lodash/keyBy\";\nimport times from \"lodash/times\";\nimport reduce from \"lodash/reduce\";\n\n/*\n    {\n        filter: [\n            {\n                dataKey: \"example\",\n                value: \"ssss\",\n                type: \"includes\"\n            }\n        ],\n        group: {\n            dataKey: \"example2\",\n            value: \"\",\n            type: \"default\"\n        },\n        sort: {\n            dataKey: \"example3\",\n            value: \"ascending\",\n            type: \"numeric\"\n        }\n    }\n*/\n\nclass TotalsCachePart {\n\n    constructor( rows, dataKey ){\n        this.rows = rows;\n        this.dataKey = dataKey;\n    }\n\n    @computed get count(){\n        return this.rows.parent.rowCount;\n    }\n\n    @computed get sum(){\n        let res = 0;\n        const { rows: { columnsByDataKey, parent }, dataKey } = this;\n        const col = columnsByDataKey[ dataKey ];\n        const { getCellData, getRowData, rowCount } = parent;\n        const fn = col.getCellData || getCellData;\n        for( let i = 0, row, cellData; i < rowCount; i++ ){\n            row = getRowData( i );\n            cellData = fn( row, i, dataKey );\n            res += cellData;\n        }\n        return res;\n    }\n\n    @computed get average(){\n        return this.sum / this.count;\n    }\n};\n\nclass RowsComplex {\n\n    constructor( parent ){\n        this.parent = parent;\n    }\n\n    @observable\n    aggregators = {\n        group: {\n            dataKey: \"country\",\n            value: \"\",\n            type: \"default\"\n        }\n    };\n\n    @action\n    modifyAggregators( arg ){\n        Object.assign( this.aggregators, arg );\n    }\n\n    @computed get totalsCache(){\n        return mapValues( this.parent.totals, ( v, k ) => new TotalsCachePart( this, k ) );\n    }\n\n    @computed get columnsByDataKey(){\n        return keyBy( this.parent.columns, \"dataKey\" );\n    }\n\n    @computed get rowIndexesArray(){\n        return times( this.parent.rowCount );\n    }\n\n    @computed get filtered(){\n\n        const { columnsByDataKey, parent } = this;\n        const { getCellData, getRowData } = parent;\n        const { filter } = this.aggregators;\n\n        if( !getCellData || !filter || !filter.length ){\n            return this.rowIndexesArray;\n        }\n\n        return this.rowIndexesArray.filter( i => {\n            const row = getRowData( i );\n            return filter.every(({ dataKey, value, type }) => {\n                const col = columnsByDataKey[ dataKey ];\n                const cellData = ( col.getCellData || getCellData )( row, i, dataKey );\n                return cellData.toString().includes( value );\n            });\n        });\n    }\n\n    @computed get grouped(){\n\n        const { group } = this.aggregators;\n\n        if( !group ){\n            return {\n                all: this.filtered\n            };\n        }\n\n        const { dataKey } = group;\n        const { columnsByDataKey, parent } = this;\n        const { getCellData, getRowData } = parent;\n\n        const col = columnsByDataKey[ dataKey ];\n\n        return groupBy( this.filtered, i => {\n            const row = getRowData( i );\n            const cellData = ( col.getCellData || getCellData )( row, i, dataKey );\n            return cellData;\n        });\n    }\n\n    @computed get sorted(){\n        const { columnsByDataKey, aggregators: { sort }, parent } = this;\n\n        if( sort ){\n            const { dataKey, value } = sort;\n            const { getCellData, getRowData } = parent;\n            const col = columnsByDataKey[ dataKey ];\n            const fn = col.getCellData || getCellData;\n            const sign = value === \"ascending\" ? 1 : -1;\n            return mapValues( this.grouped, v => v.sort(( a, b ) => {\n                const row1 = getRowData( a );\n                const row2 = getRowData( b );\n                const cell1 = fn( row1, a, dataKey );\n                const cell2 = fn( row2, b, dataKey );\n                if( cell1 > cell2 ){\n                    return sign;\n                }\n                if( cell1 < cell2 ){\n                    return -sign;\n                }\n                return 0;\n            }));\n        }\n        \n        return this.grouped;\n    }\n\n    @computed get flat(){\n        return reduce( this.sorted, ( result, groupArr, groupName ) => {\n            result.push( groupName, ...groupArr );\n            return result;\n        }, []);\n    }\n\n    @computed get visibleRowCount(){\n        return this.flat.length;\n    }\n}\n\nexport default RowsComplex;","import { observable, extendObservable, computed } from \"mobx\";\nimport add from \"lodash/add\";\nimport RowsComplex from \"./RowsComplex\";\n\n/*\n    can't extend from both FixedSizeList and VariableSizeList, so exporting compositor\n*/\nconst createTable = BaseClass => class extends BaseClass {\n\n    Rows = new RowsComplex( this );\n\n    @computed get tbodyColumnWidthsSum(){\n        return this.tbodyColumnWidths.reduce( add );\n    }\n\n    constructor(){\n        super();\n\n        extendObservable( this, {\n            columns: [],\n            totals: {},\n            headlessMode: false,\n            getCellData: null,\n            tbodyColumnWidths: []\n        });\n    }\n\n    destructor(){\n        super.destructor();\n    }\n}\n\nexport default createTable;","import { extendObservable, computed, action, observable } from \"mobx\";\nimport clamp from \"lodash/clamp\";\n\nconst getRowDataInitial = () => {\n    throw new Error( \"getRowData must be provided\" );\n}\n\nconst BASIC_OBSERVABLE_FIELDS = {\n    rowCount: 0,\n    overscanRowsCount: 0,\n    estimatedRowHeightFallback: 0,\n\n    scrollLeft: 0,\n    scrollTop: 0,\n\n    widgetHeight: 0,\n    widgetWidth: 0,\n\n    getRowKey: undefined,\n    getRowData: getRowDataInitial,\n\n    rowsContainerNode: null,\n    scrollContainerNode: null\n};\n\nconst END_INDEX_CHECK_INTERVAL = 400;\n\nclass ScrollableRowsBase {\n\n    @computed get visibleRangeStart(){\n        return this.getVisibleRangeStart( this.scrollTop );\n    }\n\n    @computed get startIndex(){\n\n        if( !this.estimatedRowHeight ){\n            return 0;\n        }\n\n        const [ newVisibleStartIndex ] = this.visibleRangeStart;\n        return Math.max( 0, newVisibleStartIndex - this.overscanRowsCount );\n    }\n\n    @computed get endIndex(){\n\n        if( !this.estimatedRowHeight ){\n            return 0;\n        }\n        \n        const [ newEndIndex ] = this.getVisibleRangeStart( this.scrollTop + this.widgetHeight );\n\n        /*\n            getVisibleRangeStart works by \"strict less\" algo. It is good for startIndex,\n            but for endIndex we need \"<=\", so adding 1 artificially.\n        */\n        return Math.min( newEndIndex + 1 + this.overscanRowsCount, this.Rows.visibleRowCount );\n    }\n\n    @computed get virtualTopOffset(){\n        const [ newVisibleStartIndex, remainder ] = this.visibleRangeStart;\n        const overscanOffset = this.getDistanceBetweenIndexes( this.startIndex, newVisibleStartIndex );\n        return this.scrollTop - remainder - overscanOffset;\n    }\n    \n    @action\n    merge( params ){\n        Object.assign( this, params );\n    }\n    \n    constructor(){\n        \n        extendObservable( this, BASIC_OBSERVABLE_FIELDS, {\n            rowsContainerNode: observable.ref,\n            scrollContainerNode: observable.ref\n        });\n        /*\n        this\n            .on( \"#widgetScrollHeight\", this.increaseEndIndexIfNeeded )\n            .on( \"#endIndex\", this.increaseEndIndexIfNeeded.cancel );\n        */\n    }\n\n    \n\n    /*\n        Column heights may change during scroll/width-change\n    */\n \n /*   increaseEndIndexIfNeededSync(){\n        const currentVisibleDist = this.getDistanceBetweenIndexes( this.startIndex, this.endIndex );\n        if( this.widgetHeight > this.virtualTopOffset + currentVisibleDist - this.scrollTop ){\n            this.updateEndIndex();\n        }\n    }\n\n    increaseEndIndexIfNeeded = debounce( this.increaseEndIndexIfNeededSync, END_INDEX_CHECK_INTERVAL );\n*/\n    destructor(){\n       // this.increaseEndIndexIfNeeded.cancel();\n    }\n\n    scrollToRow( index ){\n        const node = this.scrollContainerNode;\n        if( node ){\n            node.scrollTop = this.getDistanceBetweenIndexes( 0, clamp( index, 0, this.Rows.visibleRowCount ) );\n        }\n        return this;    \n    }\n\n    scrollToStart(){\n        return this.scrollToRow( 0 );\n    }\n};\n\nexport default ScrollableRowsBase;","import createTable from \"./createTable\";\nimport FixedSizeScrollableRows from \"./FixedSizeScrollableRows\";\n\nexport default createTable( FixedSizeScrollableRows );","import { computed } from \"mobx\";\nimport ScrollableRowsBase from \"./ScrollableRowsBase\";\n\nclass FixedSizeScrollableRows extends ScrollableRowsBase {\n\n    @computed({ keepAlive: true }) get estimatedRowHeight(){\n        if( this.widgetWidth ){\n            const node = this.rowsContainerNode;\n\n            if( node ){\n                const { firstElementChild } = node;\n                if( firstElementChild ){\n                    return firstElementChild.offsetHeight;\n                }\n            }\n        }\n        return this.estimatedRowHeightFallback;\n    }\n\n    set estimatedRowHeight( value ){\n        this.estimatedRowHeightFallback = value;\n    }\n\n    @computed get widgetScrollHeight(){\n        return this.estimatedRowHeight * this.Rows.visibleRowCount;\n    }\n\n    getVisibleRangeStart( distance ){\n        const { estimatedRowHeight } = this;\n        return estimatedRowHeight ? [ distance / estimatedRowHeight | 0, distance % estimatedRowHeight ] : [ 0, 0 ];\n    }\n\n    getDistanceBetweenIndexes( startIndex, endIndex ){\n        return this.estimatedRowHeight * ( endIndex - startIndex );\n    }\n};\n\nexport default FixedSizeScrollableRows;","import { computed } from \"mobx\";\nimport groupBy from \"lodash/groupBy\";\nimport keyBy from \"lodash/keyBy\";\nimport times from \"lodash/times\";\n\nclass RowsSimple {\n\n    constructor( parent ){\n        this.parent = parent;\n    }\n\n    get visibleRowCount(){\n        return this.parent.rowCount;\n    }\n}\n\nexport default RowsSimple;","import createTable from \"./createTable\";\nimport VariableSizeList from \"./VariableSizeList\";\n\nexport default createTable( VariableSizeList );","import RowsSimple from \"./RowsSimple\";\n\nconst createList = BaseClass => class extends BaseClass {\n    Rows = new RowsSimple( this );\n};\n\nexport default createList;","import createList from \"./createList\";\nimport VariableSizeScrollableRows from \"./VariableSizeScrollableRows\";\n\nexport default createList( VariableSizeScrollableRows );","import ScrollableRowsBase from \"./ScrollableRowsBase\";\nimport { observable, extendObservable, computed, autorun, action, runInAction, reaction } from \"mobx\";\n\n/*\n    We should always have some extra space for new rows. We do not want to reallocate cache every time.\n*/\nconst MIN_TREE_CACHE_OFFSET = 15;\n\nconst ROW_MEASUREMENT_DEBOUNCE_INTERVAL = 200;\n\nclass VariableSizeScrollableRows extends ScrollableRowsBase {\n\n    rowsDomObserver = new MutationObserver(() => runInAction(() => {\n        this.lastRowsRenderTimeStamp = performance.now();\n    }));\n\n    disposeCallbacks = [];\n\n    @computed({ keepAlive: true }) get N(){\n        /* Nearest pow of 2 to visibleRowCount. 56 >= 64, 67 => 128, etc. */\n        const { visibleRowCount }  = this.Rows;\n        return visibleRowCount > 0 ? 2 << Math.log2( visibleRowCount + MIN_TREE_CACHE_OFFSET ) : 1;\n    }\n\n    @computed({ keepAlive: true }) get sTree(){\n        // Uint16 cannot be used here, because array stores intermediate sums, which can be huge.\n        return new Uint32Array( this.N << 1 );\n    }\n\n    calculateParentsInRange( startIndex, endIndex ){\n        const { sTree, N } = this;\n    \n        for( endIndex += N, startIndex += N; endIndex >>= 1; ){\n            for( let i = startIndex >>= 1; i <= endIndex; i++ ){\n                sTree[ i ] = sTree[ i << 1 ] + sTree[ i << 1 | 1 ];\n            }\n        }\n\n        /* In segments tree 1 node is always sum of all elements */\n        this.merge({ widgetScrollHeight: sTree[ 1 ] });\n    }\n   \n    getVisibleRangeStart( dist ){\n\n        const { widgetScrollHeight, estimatedRowHeight, sTree, N } = this;\n\n        if( widgetScrollHeight && estimatedRowHeight ){\n            let nodeIndex = 1, v;\n\n            while( nodeIndex < N ){\n                v = sTree[ nodeIndex <<= 1 ];\n                if( dist >= v ){\n                    dist -= v;\n                    nodeIndex |= 1;\n                }\n            }\n    \n            return [ nodeIndex - N, dist ];\n        }\n        \n        return [ 0, 0 ];\n    }\n\n    constructor(){\n        super();\n\n        extendObservable( this, {\n            estimatedRowHeight: 20,\n            widgetScrollHeight: 0,\n            lastRowsRenderTimeStamp: 0,\n        \n            /*\n                When all row heights are different,\n                we must \"predict\" them on the left of startIndex and on the right of endIndex(where they are invisible),\n                basing on what we know: heights between startIndex and endIndex.\n                Using simple average by default.\n            */\n            shouldResetInvisibleRowHeights: true\n        });\n\n        this.disposeCallbacks.push(\n            autorun(() => {\n\n                //superdirty\n                if( !this.rowCount ){\n                    return;\n                }\n                \n                const { sTree, estimatedRowHeight, N, Rows: { visibleRowCount } } = this;\n                sTree.fill( estimatedRowHeight, N, N + visibleRowCount );\n                if( estimatedRowHeight ){\n                    /*\n                        Trees are not always ideally allocated, gaps are possible.\n                        Classical way for calculating parents is much simpler,\n                        but can do much more work(summing zeros) in such conditions. Commented classic algo:\n                \n                        for( let i = N + visibleRowCount >> 1, j; i > 0; --i ){\n                            j = i << 1;\n                            sTree[ i ] = sTree[ j ] + sTree[ j | 1 ];\n                        }\n                    */\n                    this.calculateParentsInRange( 0, visibleRowCount );\n                }\n            }),\n            autorun(() => {\n                if( this.widgetWidth ){\n                    this.merge({\n                        shouldResetInvisibleRowHeights: true\n                    });\n                }\n            }),\n            autorun(() => {\n                this.rowsDomObserver.disconnect();\n                if( this.rowsContainerNode ){\n                    this.rowsDomObserver.observe( this.rowsContainerNode, { childList: true, subtree: true });\n                }\n            }),\n            reaction(\n                () => this.lastRowsRenderTimeStamp * this.widgetWidth,\n                () => {\n                    const node = this.rowsContainerNode;\n    \n                    if( node ){\n                        const { sTree, N } = this;\n                        \n                        let l = -1,\n                            r = -1,\n                            rowHeightsSum = 0,\n                            rowCounter = 0;\n            \n                        /*\n                            Some benchmarks inspire me to use nextElementSibling\n                            https://jsperf.com/nextsibling-vs-childnodes-increment/2\n                        */\n                        for( let child = node.firstElementChild, newHeight, index; child; child = child.nextElementSibling, rowCounter++ ){\n                            \n                            /*\n                                * aria-rowindex is counted from 1 according to w3c spec;\n                                * parseInt with radix is 2x faster, then +, -, etc.\n                                  https://jsperf.com/number-vs-parseint-vs-plus/116\n                            */\n                            index = parseInt( child.getAttribute( \"aria-rowindex\" ), 10 ) - 1;\n            \n                            if( process.env.NODE_ENV !== \"production\" && Number.isNaN( index ) ){\n                                throw new Error( \"aria-rowindex attribute must be present on each row. Look at default Row implementations.\" );\n                            }\n            \n                            newHeight = child.offsetHeight;\n                            rowHeightsSum += newHeight;\n            \n                            if( sTree[ N + index ] !== newHeight ){\n                                // console.log( \"%d| was: %d; is: %d\", index, sTree[N+index],newHeight)\n                                sTree[ N + index ] = newHeight;\n                                \n                                if( l === -1 ){\n                                    l = index;\n                                }\n                                \n                                r = index;\n                            }\n                        }\n             \n                        if( l !== -1 ){\n                            if( process.env.NODE_ENV !== \"production\" ){\n                                console.log( \"Updating heights in range: %d - %d\", l, r );\n                            }\n            \n                            if( this.shouldResetInvisibleRowHeights ){\n                                this.merge({\n                                    estimatedRowHeight: Math.round( rowHeightsSum / rowCounter ),\n                                    shouldResetInvisibleRowHeights: false\n                                });\n                            }\n                            else{\n                                this.calculateParentsInRange( l, r )\n                            }\n                        }\n                    }\n                },\n                { delay: ROW_MEASUREMENT_DEBOUNCE_INTERVAL }\n            )\n        );\n    }\n\n    destructor(){\n        this.disposeCallbacks.forEach( cb => cb() );\n        super.destructor();\n    }\n\n    getDistanceBetweenIndexes( startIndex, endIndex ){\n\n        if( !this.estimatedRowHeight ){\n            return 0;\n        }\n\n        const { sTree, N } = this;\n        let res = 0;\n\n        for( startIndex += N, endIndex += N; startIndex < endIndex; startIndex >>= 1, endIndex >>= 1 ){\n            if( startIndex & 1 ){\n                res += sTree[ startIndex++ ];\n            }\n\n            if( endIndex & 1 ){\n                res += sTree[ --endIndex ]; \n            }\n        };\n\n        return res; \n    }\n};\n\nexport default VariableSizeScrollableRows;","const getPropsGetter = propName => ( data, index, dataIndex, getExtraProps ) => {\n\n    /* avoiding double destructurization via getExtraProps, so making prop object once */\n    const props = {\n        [propName]: index + 1\n    };\n\n    if( getExtraProps ){\n        const extraProps = getExtraProps( data, index, dataIndex );\n        if( extraProps ){\n            if( process.env.NODE_ENV !== \"production\" ){\n                if( extraProps.hasOwnProperty( propName ) ){\n                    throw new Error( `getExtraProps must not override ${propName}` );\n                }\n            }\n            Object.assign( props, extraProps );\n        }\n    }\n\n    return props;\n}\n\nexport const getRowProps = getPropsGetter( \"aria-rowindex\" );\nexport const getCellProps = getPropsGetter( \"aria-colindex\" );","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getRowProps } from \"../../utils/extraPropsGetters\";\n\nconst Row = ({ columns, CellComponent, getRowData, getCellData, getRowExtraProps, getCellExtraProps, rowDataIndex, rowIndex }) => {\n\n    const rowData = getRowData( rowDataIndex );\n\n    return (\n        <tr {...getRowProps(rowData,rowIndex,rowDataIndex,getRowExtraProps)}>\n            {columns.map(( column, columnIndex ) => {\n                if( column.visibility === \"hidden\" ){\n                    return null;\n                }\n\n                const FinalCellComponent = column.CellComponent || CellComponent;\n\n                return (\n                    <FinalCellComponent\n                        key={column.dataKey}\n                        rowData={rowData}\n                        rowIndex={rowIndex}\n                        column={column}\n                        columnIndex={columnIndex}\n                        getCellData={getCellData}\n                        getCellExtraProps={column.getCellExtraProps||getCellExtraProps}\n                    />\n                );\n            })}\n        </tr>\n    );\n};\n\nRow.propTypes = {\n    getCellData: PropTypes.func.isRequired,\n    columns: PropTypes.array.isRequired,\n    CellComponent: PropTypes.elementType.isRequired,\n    getRowData: PropTypes.func.isRequired,\n    rowIndex: PropTypes.number.isRequired,\n    rowDataIndex: PropTypes.number.isRequired,\n    getRowExtraProps: PropTypes.func,\n    getCellExtraProps: PropTypes.func\n};\n\nexport default Row;","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getCellProps } from \"../../utils/extraPropsGetters\";\n\n/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/\nconst DEFAULT_EMPTY_CELL_CONTENT = \"\\u00A0\";\n\nconst Cell = ({ rowData, rowIndex, getCellData: getCellDataDefault, column, columnIndex, getCellExtraProps }) => {\n    const { render, getEmptyCellData, dataKey, format, getCellData } = column;\n\n    let cellData = rowData && ( getCellData || getCellDataDefault )( rowData, rowIndex, dataKey );\n    \n    if( cellData === undefined || cellData === \"\" ){\n        cellData = getEmptyCellData ? getEmptyCellData( rowIndex, column ) : DEFAULT_EMPTY_CELL_CONTENT;\n    }\n    else{\n        if( format ){\n            cellData = format( cellData, rowData );\n        }\n        if( render ){\n            cellData = render( cellData, rowData, column );\n        }\n    }\n\n    return (\n        <td {...getCellProps(rowData,columnIndex,columnIndex,getCellExtraProps)}>\n            {cellData}\n        </td>\n    );\n};\n\nCell.propTypes = {\n    getCellData: PropTypes.func.isRequired,\n    rowIndex: PropTypes.number.isRequired,\n    columnIndex: PropTypes.number.isRequired,\n    column: PropTypes.object.isRequired,\n    rowData: PropTypes.object,\n    getCellExtraProps: PropTypes.func\n};\n\nexport default Cell;","import React, { Fragment } from \"react\";\nimport { observer } from \"mobx-react-lite\";\n\nconst Total = observer(({ cache, showSummaryType, summaryType, formatTotal }) => {\n    const res = cache[ summaryType ];\n\n    return res !== undefined ? (\n        <div key={summaryType} title={summaryType} className=\"afvscr-summary\">\n            {showSummaryType ? (\n                <Fragment>{summaryType}&nbsp;</Fragment>\n            ) : null}\n            {formatTotal?formatTotal(res):res}\n        </div>\n    ) : null;\n});\n\nconst TotalsCell = ({ cellTotals, totalsCache, formatTotal }) => {\n\n    if( !cellTotals || !totalsCache ){\n        return null;\n    }\n\n    if( cellTotals.length === 1 ){\n        return (\n            <Total\n                summaryType={cellTotals[0]}\n                cache={totalsCache}\n                formatTotal={formatTotal}\n            />\n        );\n    }\n\n    return cellTotals.map( summaryType => (\n        <Total\n            showSummaryType\n            summaryType={summaryType}\n            cache={totalsCache}\n            formatTotal={formatTotal}\n        />\n    ));\n};\n\nexport default observer( TotalsCell );","const cx = ( baseClass, extraClass ) => extraClass ? `${baseClass} ${extraClass}` : baseClass;\n\nexport default cx;","import React from \"react\";\nimport cx from \"../utils/cx\"\n\nconst RowCountWarningContainer = ({ className, ...props }) => <div className={cx(\"afvscr-row-count-warning-container\",className)} {...props} />;\n\nexport default RowCountWarningContainer;","import { useContext } from \"react\";\nimport Context from \"../Context\";\n\nconst useApi = () => useContext( Context );\n\nexport default useApi;\n","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport useApi from \"../../useApi\";\n\nconst Colgroup = ({ useTbodyWidths }) => {\n\n    const { columns, tbodyColumnWidths } = useApi();\n\n    return (\n        <colgroup>\n            {columns.map(({ dataKey, background, visibility, border, width }, j ) => visibility !== \"hidden\" ? (\n                <col\n                    key={dataKey}\n                    style={{\n                        width: useTbodyWidths ? tbodyColumnWidths[ j ] : width,\n                        background,\n                        border\n                    }}\n                />\n            ) : null )}\n        </colgroup>\n    );\n};\n\nexport default observer( Colgroup );","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport useApi from \"../../../useApi\";\nimport Colgroup from \"../../common/Colgroup\";\nimport cx from \"../../../utils/cx\";\n\nconst TableWrapper = ({ children, className, ...props }) => {\n\n    const { scrollLeft, columns, tbodyColumnWidthsSum } = useApi();\n\n    const style = {\n        /* If we do this via transform translate, col background would have bugs during horizontal scroll. Strange webkit behavior */\n        marginLeft: -scrollLeft,\n        width: tbodyColumnWidthsSum\n    };\n\n    return (\n        <table className={cx(\"afvscr-nonst-subtable\",className)} {...props} style={style} aria-colcount={columns.length}>\n            <Colgroup useTbodyWidths />\n            {children}\n        </table>\n    );\n};\n\nexport default observer( TableWrapper );","import React from \"react\";\nimport useApi from \"../../useApi\";\nimport { observer } from \"mobx-react-lite\";\n\nconst HeaderCells = () => {\n\n    const { columns, Rows } = useApi();\n    const { sort } = Rows.aggregators;\n\n    return columns.map(({ dataKey, title, sort: colSort, label, visibility }, j ) => visibility === \"hidden\" ? null : (\n        <th\n            key={dataKey}\n            title={title}\n            data-sortable={colSort?\"\":undefined}\n            aria-colindex={j+1}\n            aria-sort={sort&&sort.dataKey === dataKey?sort.value:\"none\"}\n        >\n            {label}\n        </th>\n    ));\n};\n\nexport default observer( HeaderCells );","import React, { useCallback, memo } from \"react\";\nimport HeaderCells from \"./HeaderCells\";\nimport useApi from \"../../useApi\";\n\nconst Thead = ({ trRef, getCellStyle, ...props }) => {\n\n    const API = useApi();\n\n    const clickHandler = useCallback( e => {\n\n        const colIndex = parseInt( e.target.getAttribute( \"aria-colindex\" ), 10 ) - 1;\n\n        if( process.env.NODE_ENV !== \"production\" && Number.isNaN( colIndex ) ){\n            throw new Error( \"colIndex attr missing\" );\n        }\n\n        const { sort, dataKey } = API.columns[ colIndex ];\n\n        if( e.ctrlKey ){\n            API.Rows.modifyAggregators({\n                group: API.Rows.aggregators.group && API.Rows.aggregators.group.dataKey === dataKey ? null : {\n                    dataKey,\n                    value: \"\"\n                }\n            });\n        }\n        else if( sort ){\n            const value = e.target.getAttribute( \"aria-sort\" ) === \"ascending\" ? \"descending\" : \"ascending\";\n            API.Rows.modifyAggregators({\n                sort: {\n                    dataKey,\n                    value\n                }\n            });\n        }\n    }, []);\n\n    return (\n        <thead {...props} onClick={clickHandler}>\n            <tr ref={trRef}>\n                <HeaderCells />\n            </tr>\n        </thead>\n    );\n};\n\nexport default memo( Thead );","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport PropTypes from \"prop-types\";\nimport useApi from \"../../useApi\";\n\nconst FooterCells = ({ TotalsCellComponent }) => {\n\n    const { columns, totals, Rows: { totalsCache } } = useApi();\n\n    return columns.map(({ dataKey, formatTotal, visibility }, j ) => {\n\n        if( visibility === \"hidden\" ){\n            return null;\n        }\n\n        const curTotals = totals[ dataKey ];\n        const curTotalsCache = totalsCache[ dataKey ];\n\n        return (\n            <td key={dataKey} aria-colindex={j+1}>\n                <TotalsCellComponent\n                    cellTotals={curTotals}\n                    totalsCache={curTotalsCache}\n                    formatTotal={formatTotal}\n                />\n            </td>\n        );\n    });\n};\n\nFooterCells.propTypes = {\n    TotalsCellComponent: PropTypes.elementType.isRequired\n}\n\nexport default observer( FooterCells );","import React, { memo } from \"react\";\nimport FooterCells from \"./FooterCells\";\n\nconst Tfoot = ({ className, trRef, TotalsCellComponent }) => (\n    <tfoot className={className}>\n        <tr ref={trRef}>\n            <FooterCells TotalsCellComponent={TotalsCellComponent} />\n        </tr>\n    </tfoot>\n);\n\nexport default memo( Tfoot );","import React, { memo } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getRowProps } from \"../../utils/extraPropsGetters\";\n\nconst GroupRow = ({ columns, groupKey, rowIndex }) => (\n    <tr {...getRowProps(null,rowIndex)}>\n        <td colSpan={columns.length} className=\"afvscr-group-cell\">\n            {groupKey}\n        </td>\n    </tr>\n);\n\nGroupRow.propTypes = {\n    columns: PropTypes.array.isRequired,\n    rowIndex: PropTypes.number.isRequired,\n    groupKey: PropTypes.string.isRequired\n};\n\nexport default memo( GroupRow );","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport useApi from \"../../useApi\";\nimport GroupRow from \"./GroupRow\";\n\nconst getVisibleRows = (\n    orderedRows,\n    rangeFrom,\n    rangeTo,\n    columns,\n    getRowData,\n    getCellData,\n    getRowKey,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent\n) => {\n    const result = [];\n    for( let rowKey, idx; rangeFrom < rangeTo; rangeFrom++ ){\n        idx = orderedRows[ rangeFrom ];\n\n        if( typeof idx === \"number\" ){\n            rowKey = getRowKey ? getRowKey( idx ) : idx;\n            result.push(\n                <RowComponent\n                    getRowExtraProps={getRowExtraProps}\n                    getCellExtraProps={getCellExtraProps}\n                    rowIndex={rangeFrom}\n                    rowDataIndex={idx}\n                    key={rowKey}\n                    columns={columns}\n                    getRowData={getRowData}\n                    getCellData={getCellData}\n                    CellComponent={CellComponent}\n                />\n            );\n        }\n        else {\n            result.push(\n                <GroupRow\n                    key={`group_${idx}`}\n                    groupKey={idx}\n                    columns={columns}\n                    rowIndex={rangeFrom}\n                />\n            );\n        }\n    }\n    return result;\n};\n\nconst Rows = ({ getRowExtraProps, getCellExtraProps, RowComponent, CellComponent }) => {\n\n    const API = useApi();\n\n    return getVisibleRows(\n        API.Rows.flat,\n        API.startIndex,\n        API.endIndex,\n        API.columns,\n        API.getRowData,\n        API.getCellData,\n        API.getRowKey,\n        getRowExtraProps,\n        getCellExtraProps,\n        RowComponent,\n        CellComponent\n    );\n};\n\nexport default observer( Rows );","import React, { memo } from \"react\";\nimport Rows from \"./Rows\";\n\nconst Tbody = ({\n    getRowExtraProps,\n    getCellExtraProps,\n    tbodyRef,\n    RowComponent,\n    CellComponent\n}) => (\n    <tbody ref={tbodyRef}>\n        <Rows\n            getRowExtraProps={getRowExtraProps}\n            getCellExtraProps={getCellExtraProps}\n            RowComponent={RowComponent}\n            CellComponent={CellComponent}\n        />\n    </tbody>\n);\n\nexport default memo( Tbody );","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport useApi from \"../../useApi\";\n\nconst BodyTable = ({ children }) => {\n\n    const API = useApi();\n\n    return (\n        <table\n            children={children}\n            className=\"afvscr-main-table\"\n            aria-rowcount={API.rowCount}\n            aria-colcount={API.columns.length}\n        />\n    );\n};\n\nexport default observer( BodyTable );","import { useRef, useEffect, useCallback } from \"react\";\n\nconst useColWidthsResizeObserver = API => {\n\n    const observerRef = useRef();\n    const mutationObserverRef = useRef();\n\n    let RO = observerRef.current;\n    let MO = mutationObserverRef.current;\n\n    if( !RO ){\n        RO = observerRef.current = new ResizeObserver( entries => {\n            for( let j = 0, colIndex; j < entries.length; j++ ){\n                const { target } = entries[ j ];\n                colIndex = parseInt( target.getAttribute( \"aria-colindex\" ) );\n\n                /*\n                    using target.offsetWidth instead of contentRect.width, because we need border-box sizing, \n                    and { box: border-box } option does not work here\n                */\n                API.tbodyColumnWidths[ colIndex - 1 ] = Math.round( target.offsetWidth );\n            }\n        });\n\n        MO = mutationObserverRef.current = new MutationObserver( entries => {\n            for( let i = 0; i < entries.length; i++ ){\n                const { addedNodes, removedNodes } = entries[ i ];\n                for( let j = 0; j < addedNodes.length; j++ ){\n                    RO.observe( addedNodes[ j ] );\n                }\n                for( let j = 0; j < removedNodes.length; j++ ){\n                    RO.unobserve( removedNodes[ j ] );\n                }\n            }   \n        });\n    }\n\n    useEffect(() => () => {\n        RO.disconnect();\n        MO.disconnect();\n    }, []);\n\n    /* callback ref */\n    return useCallback( trNode => {\n        MO.disconnect();\n        RO.disconnect();\n        if( trNode ){\n            MO.observe( trNode, { childList: true });\n        }\n    }, []);\n};\n\nexport default useColWidthsResizeObserver;","import React from \"react\";\nimport useApi from \"../useApi\";\nimport { observer } from \"mobx-react-lite\";\n\nconst Scroller = ({ Component }) => {\n\n    const { virtualTopOffset } = useApi();\n\n    /*\n        Hmm, I can't put here more than ~ 3 000 000. Maybe need to put one more row in case this height is > 3 000 000\n    */\n    return <Component className=\"afvscr-scroller\" aria-hidden=\"true\" style={{ height: virtualTopOffset }} />;\n};\n\nexport default observer( Scroller );","import React from \"react\";\nimport Scroller from \"../../common/Scroller\";\n\n/*\n    According to specs, tr must always be inside tbody, thead or tfoot                \n*/\nconst TbodyScroller = () => (\n    <tbody className=\"afvscr-scroller\" aria-hidden=\"true\">\n        <Scroller Component=\"tr\" />\n    </tbody>\n);\n\nexport default TbodyScroller;","import React, { cloneElement } from \"react\";\nimport useApi from \"../useApi\";\nimport { observer } from \"mobx-react-lite\";\n\nconst el = <div aria-hidden=\"true\" className=\"afvscr-height-provider\" />;\n\nconst HeightProvider = () => cloneElement( el, {\n    style: {\n        height: useApi().widgetScrollHeight\n    }\n});\n\nexport default observer( HeightProvider );","import React, { forwardRef, useCallback, useEffect } from \"react\";\nimport cx from \"../utils/cx\";\nimport HeightProvider from \"./HeightProvider\";\nimport useApi from \"../useApi\";\n\nconst ScrollContainer = forwardRef(({\n    className,\n    children,\n    onScroll,\n    ...props\n}, ref ) => {\n\n    const API = useApi();\n\n    const scrollHandler = useCallback( e => {\n        const { scrollTop, scrollLeft } = e.target;\n        API.merge({\n            scrollLeft,\n            scrollTop\n        });\n        if( onScroll ){\n            onScroll( e );\n        }\n    }, [ onScroll ]);\n\n    useEffect(() => {\n        const el = ref.current;\n\n        const R = new ResizeObserver( entries => {\n            if( entries.length === 1 ){\n                /*\n                    using target.offsetWidth instead of contentRect.width, because we need border-box sizing, \n                    and { box: border-box } option does not work here\n                */\n                const { offsetWidth, offsetHeight } = entries[ 0 ].target;\n\n                API.merge({\n                    widgetHeight: Math.round( offsetHeight ),\n                    widgetWidth: Math.round( offsetWidth )\n                });\n            }\n        });\n\n        R.observe( el );\n\n        return () => {\n            R.unobserve( el );\n        };\n    }, []);\n    \n    /*\n        tabIndex=\"0\" is for proper keyboard nav\n        https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\n    */\n    return (\n        <div tabIndex=\"0\" className={cx(\"afvscr-scroll-container\",className)} ref={ref} onScroll={scrollHandler} {...props}>\n            <HeightProvider />\n            {children}\n        </div>\n    );\n});\n\nexport default ScrollContainer;","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport PropTypes from \"prop-types\";\n\nimport useApi from \"../../useApi\";\nimport TableWrapper from \"./TableWrapper\";\n\nimport Thead from \"../common/Thead\";\nimport Tfoot from \"../common/Tfoot\";\nimport Tbody from \"../common/Tbody\";\nimport BodyTable from \"../common/BodyTable\";\n\nimport useColWidthsResizeObserver from \"./useColWidthsResizeObserver\";\nimport Colgroup from \"../common/Colgroup\";\nimport TbodyScroller from \"../common/TbodyScroller\";\nimport ScrollContainer from \"../../common/ScrollContainer\";\nimport cx from \"../../utils/cx\";\n\nconst NonSticky = ({\n    className,\n    tbodyRef,\n    scrollContainerRef,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent,\n    TotalsCellComponent,\n    onScroll,\n    ...props\n}) => {\n\n    const API = useApi();\n\n    const { headlessMode, totals } = API;\n\n    /*\n        Hidden tfoot & thead are needed to 'hold' widths of tbody columns no to be narrower than real thead/tfoot\n        and notify model about columns width changes.\n        There are 3 tables rendered in this mode, so their column widths need to be synced somehow.\n    */\n    const widthsObserverRef = useColWidthsResizeObserver( API );\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        if( headlessMode && !totals ){\n            console.warn( \"NonSticky table is rendered without headers and footers. This is not ok.\" )\n        }\n    }\n\n    return (\n        <div className={cx(\"afvscr-nonst\",className)} {...props}>\n            {headlessMode ? null : (\n                <TableWrapper>\n                    <Thead />\n                </TableWrapper>\n            )}\n            <ScrollContainer ref={scrollContainerRef} onScroll={onScroll}>\n                <BodyTable>\n                    <Colgroup />\n                    {headlessMode ? null : (\n                        <Thead\n                            className=\"afvscr-hdnwrp\"\n                            trRef={widthsObserverRef}\n                        />\n                    )}\n                    {totals && (\n                        <Tfoot\n                            TotalsCellComponent={TotalsCellComponent}\n                            className=\"afvscr-hdnwrp\"\n                            trRef={headlessMode?widthsObserverRef:undefined}\n                        />\n                    )}\n                    <TbodyScroller />\n                    <Tbody\n                        tbodyRef={tbodyRef}\n                        getRowExtraProps={getRowExtraProps}\n                        getCellExtraProps={getCellExtraProps}\n                        RowComponent={RowComponent}\n                        CellComponent={CellComponent}\n                    />\n                </BodyTable>\n            </ScrollContainer>\n            {totals && (\n                <TableWrapper>\n                    <Tfoot TotalsCellComponent={TotalsCellComponent} />\n                </TableWrapper>\n            )}\n        </div>\n    );\n};\n\nexport default observer( NonSticky );","import React, { useEffect } from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport Colgroup from \"../common/Colgroup\";\nimport TbodyScroller from \"../common/TbodyScroller\";\nimport ScrollContainer from \"../../common/ScrollContainer\";\nimport Thead from \"../common/Thead\";\nimport Tbody from \"../common/Tbody\";\nimport Tfoot from \"../common/Tfoot\";\nimport BodyTable from \"../common/BodyTable\";\nimport useApi from \"../../useApi\";\nimport cx from \"../../utils/cx\";\n\n\n/*\n    Todo:\n        measure thead & tfoot heights in order to properly calculate available space for rows\n*/\n\n\nconst Sticky = ({\n    tbodyRef,\n    scrollContainerRef,\n    getRowExtraProps,\n    getCellExtraProps,\n    RowComponent,\n    CellComponent,\n    TotalsCellComponent,\n    className,\n    ...props\n}) => {\n\n    const { headlessMode, totals } = useApi();\n\n    if( process.env.NODE_ENV !== \"production\" ){\n        /*\n            https://bugs.chromium.org/p/chromium/issues/detail?id=702927\n        */\n\n        const areTotalsPresent = totals && totals.length !== 0;\n\n        useEffect(() => {\n            if( !headlessMode || areTotalsPresent ){\n                /* TODO: tests fail without this if */\n                if( scrollContainerRef.current ){\n                    const table = scrollContainerRef.current.querySelector( \"table\" );\n                    const tableStyle = getComputedStyle( table );\n    \n                    if( tableStyle.borderCollapse === \"collapse\" ){\n                        console.warn(\n                            \"You use sticky table version. Due to special border behavior when scrolling, use border-collpase: separate.%o\",\n                            \"https://bugs.chromium.org/p/chromium/issues/detail?id=702927\"\n                        );\n                    }\n                }\n            }\n        }, [ headlessMode, areTotalsPresent ]);\n    }\n    \n    return (\n        <ScrollContainer ref={scrollContainerRef} className={cx(\"afvscr-st\",className)} {...props}>\n            <BodyTable>\n                <Colgroup />\n                {headlessMode?null:<Thead />}\n                <TbodyScroller />\n                <Tbody\n                    tbodyRef={tbodyRef}\n                    getRowExtraProps={getRowExtraProps}\n                    getCellExtraProps={getCellExtraProps}\n                    RowComponent={RowComponent}\n                    CellComponent={CellComponent}\n                />\n                {totals && (\n                    <Tfoot TotalsCellComponent={TotalsCellComponent} />\n                )}\n            </BodyTable>\n        </ScrollContainer>\n    );\n}\n\nexport default observer( Sticky );","const commonDefaultProps = {\n    fixedSize: false,\n    rowCount: 0,\n    overscanRowsCount: 4,\n    estimatedRowHeight: 16\n};\n\nexport default commonDefaultProps;","import React, { memo } from \"react\";\nimport PropTypes from \"prop-types\";\n\nimport isPositionStickySupported from \"../utils/isPositionStickySupported\";\nimport Context from \"../Context\";\nimport useStore from \"../utils/useStore\";\n\nimport FixedSizeTableStore from \"../models/FixedSizeTable\";\nimport VariableSizeTableStore from \"../models/VariableSizeTable\";\n\nimport RowComponentDefault from \"./common/Row\";\nimport CellComponentDefault from \"./common/Cell\";\nimport TotalsCellComponentDefault from \"./common/TotalsCell\";\n\nimport RowCountWarningContainerDefault from \"../common/RowCountWarningContainer\";\n\nimport NonStickyComponent from \"./NonSticky\";\nimport StickyComponent from \"./Sticky\";\n\nimport commonPropTypes from \"../commonPropTypes\";\nimport commonDefaultProps from \"../commonDefaultProps\";\nimport cx from \"../utils/cx\";\n\nconst Table = ({\n    fixedSize,\n    estimatedRowHeight,\n    columns,\n    totals,\n    getRowData,\n    getCellData,\n    getRowKey,\n    getRowExtraProps,\n    getCellExtraProps,\n    rowCount,\n    overscanRowsCount,\n    rowCountWarningsTable,\n    headless,\n    RowCountWarningContainer,\n    dataRef,\n    nonSticky,\n    className,\n    ...props\n}) => {\n\n    const [ Store, scrollContainerRef, tbodyRef ] = useStore( fixedSize ? FixedSizeTableStore : VariableSizeTableStore, dataRef, {\n        headlessMode: headless,\n        getRowData,\n        getCellData,\n        getRowKey,\n        overscanRowsCount,\n        estimatedRowHeight,\n        totals,\n        columns,\n        rowCount\n    });\n\n    /*\n        Only cells inside thead/tfoot can be sticky.\n        If thead/tfoot are hidden - we can easily render lighter StickyComponent to avoid extra wrappers\n    */\n    const ComponentVariant = ( headless && !totals ) || ( !nonSticky && isPositionStickySupported() ) ? StickyComponent : NonStickyComponent;\n\n    return (\n        <Context.Provider value={Store}>\n            { rowCount > 0 ? (\n                <ComponentVariant\n                    className={cx(\"afvscr-table-wrapper\",className)}\n                    scrollContainerRef={scrollContainerRef}\n                    getRowExtraProps={getRowExtraProps}\n                    getCellExtraProps={getCellExtraProps}\n                    tbodyRef={tbodyRef}\n                    {...props}\n                />\n            ) : rowCountWarningsTable ? (\n                <RowCountWarningContainer>\n                    {rowCountWarningsTable[rowCount]}\n                </RowCountWarningContainer>\n            ) : null }\n        </Context.Provider>\n    );\n}\n\nTable.propTypes = {\n    ...commonPropTypes,\n    columns: PropTypes.arrayOf(\n        PropTypes.shape({\n            // unique key for column\n            dataKey: PropTypes.string.isRequired,\n\n            // for details see CellComponent implementation\n            getCellData: PropTypes.func,\n            getEmptyCellData: PropTypes.func,\n            format: PropTypes.func,\n            render: PropTypes.func,\n            formatTotal: PropTypes.func,\n\n            visibility: PropTypes.oneOf([ \"visible\", \"hidden\" ]),\n            sort: PropTypes.oneOf([ \"locale\", \"numeric\" ]),\n\n            // column props, affecting colgroup > col tags\n            background: PropTypes.string,\n            border: PropTypes.string,\n            width: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\n            CellComponent: PropTypes.elementType,\n            getCellExtraProps: PropTypes.func\n        })\n    ).isRequired,\n\n    getCellExtraProps: PropTypes.func,\n\n    totals: PropTypes.objectOf(\n        // array may contain: \"sum\", \"average\", \"count\", \"max\", \"min\"\n        PropTypes.array\n    ),\n    \n    nonSticky: PropTypes.bool,\n    headless: PropTypes.bool,\n\n    HeaderRowComponent: PropTypes.elementType,\n    CellComponent: PropTypes.elementType,\n    getCellData: PropTypes.func,\n    TotalsCellComponent: PropTypes.elementType,\n\n    RowCountWarningContainer: PropTypes.elementType,\n    rowCountWarningsTable: PropTypes.object\n};\n\nTable.defaultProps = {\n    ...commonDefaultProps,\n    headless: false,\n\n    //    For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.\n    //    If RowComponent should be wrapped my mobx observer - non-memo version should be imported.\n    //    memo(observer(RowComponentDefault)) will do the trick.\n    \n    RowComponent: memo( RowComponentDefault ),\n    CellComponent: CellComponentDefault,\n    getCellData: ( rowData, rowIndex, dataKey ) => rowData[ dataKey ],\n    TotalsCellComponent: TotalsCellComponentDefault,\n    RowCountWarningContainer: RowCountWarningContainerDefault,\n};\n\nexport default memo( Table );","import React from \"react\";\nimport Table from \"af-virtual-scroll/src/Table\";\n\nconst columns = [\n    {\n        dataKey: \"a\",\n        label: \"a\"\n    },\n    {\n        dataKey: \"b\",\n        label: \"b\"\n    },\n    {\n        dataKey: \"c\",\n        label: \"c\"\n    }\n];\n\nconst getRowData = index => ({\n    a: index,\n    b: `cell_b_row: ${index}`,\n    c: `cell_c_row: ${index}`\n})\n\nconst SimpleTable = ({ className }) => (\n    <Table\n        className={className}\n        getRowData={getRowData}\n        rowCount={500}\n        columns={columns}\n        estimatedRowHeight={200}\n    />\n);\n\nexport default SimpleTable;"],"sourceRoot":""}