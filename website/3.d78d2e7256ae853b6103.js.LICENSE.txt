/*
     * some custom renderers rely on individual row elements so we need to turn wrapLines on
     * if renderer is provided and wrapLines is undefined
     */

/* 0-9 */

/* A */

/* A-Z */

/* WEBPACK VAR INJECTION */

/* Z */

/* a */

/* a-z */

/* eslint-env browser */

/* global window, self */

/* harmony default export */

/* harmony import */

/* istanbul ignore else - Clean leaks after Prism. */

/* istanbul ignore next */

/* z */

/*#__PURE__*/

/**
		 * Adds the given callback to the list of callbacks for the given hook.
		 *
		 * The callback will be invoked when the hook it is registered for is run.
		 * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
		 *
		 * One callback function can be registered to multiple hooks and the same hook multiple times.
		 *
		 * @param {string} name The name of the hook.
		 * @param {HookCallback} callback The callback function which is given environment variables.
		 * @public
		 */

/**
		 * Creates a deep clone of the given object.
		 *
		 * The main intended use of this function is to clone language definitions.
		 *
		 * @param {T} o
		 * @param {Record<number, any>} [visited]
		 * @returns {T}
		 * @template T
		 */

/**
		 * Creates a deep copy of the language with the given id and appends the given tokens.
		 *
		 * If a token in `redef` also appears in the copied language, then the existing token in the copied language
		 * will be overwritten at its original position.
		 *
		 * ## Best practices
		 *
		 * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
		 * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
		 * understand the language definition because, normally, the order of tokens matters in Prism grammars.
		 *
		 * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
		 * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
		 *
		 * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
		 * @param {Grammar} redef The new tokens to append.
		 * @returns {Grammar} The new language created.
		 * @public
		 * @example
		 * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
		 *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
		 *     // at its original position
		 *     'comment': { ... },
		 *     // CSS doesn't have a 'color' token, so this token will be appended
		 *     'color': /\b(?:red|green|blue)\b/
		 * });
		 */

/**
		 * Inserts tokens _before_ another token in a language definition or any other grammar.
		 *
		 * ## Usage
		 *
		 * This helper method makes it easy to modify existing languages. For example, the CSS language definition
		 * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
		 * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
		 * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
		 * this:
		 *
		 * ```js
		 * Prism.languages.markup.style = {
		 *     // token
		 * };
		 * ```
		 *
		 * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
		 * before existing tokens. For the CSS example above, you would use it like this:
		 *
		 * ```js
		 * Prism.languages.insertBefore('markup', 'cdata', {
		 *     'style': {
		 *         // token
		 *     }
		 * });
		 * ```
		 *
		 * ## Special cases
		 *
		 * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
		 * will be ignored.
		 *
		 * This behavior can be used to insert tokens after `before`:
		 *
		 * ```js
		 * Prism.languages.insertBefore('markup', 'comment', {
		 *     'comment': Prism.languages.markup.comment,
		 *     // tokens after 'comment'
		 * });
		 * ```
		 *
		 * ## Limitations
		 *
		 * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
		 * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
		 * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
		 * deleting properties which is necessary to insert at arbitrary positions.
		 *
		 * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
		 * Instead, it will create a new object and replace all references to the target object with the new one. This
		 * can be done without temporarily deleting properties, so the iteration order is well-defined.
		 *
		 * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
		 * you hold the target object in a variable, then the value of the variable will not change.
		 *
		 * ```js
		 * var oldMarkup = Prism.languages.markup;
		 * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
		 *
		 * assert(oldMarkup !== Prism.languages.markup);
		 * assert(newMarkup === Prism.languages.markup);
		 * ```
		 *
		 * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
		 * object to be modified.
		 * @param {string} before The key to insert before.
		 * @param {Grammar} insert An object containing the key-value pairs to be inserted.
		 * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
		 * object to be modified.
		 *
		 * Defaults to `Prism.languages`.
		 * @returns {Grammar} The new grammar object.
		 * @public
		 */

/**
		 * Returns a unique number for the given object. Later calls will still return the same number.
		 *
		 * @param {Object} obj
		 * @returns {number}
		 */

/**
		 * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
		 *
		 * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
		 *
		 * @param {Element} element
		 * @returns {string}
		 */

/**
		 * Returns the name of the type of the given value.
		 *
		 * @param {any} o
		 * @returns {string}
		 * @example
		 * type(null)      === 'Null'
		 * type(undefined) === 'Undefined'
		 * type(123)       === 'Number'
		 * type('foo')     === 'String'
		 * type(true)      === 'Boolean'
		 * type([1, 2])    === 'Array'
		 * type({})        === 'Object'
		 * type(String)    === 'Function'
		 * type(/abc+/)    === 'RegExp'
		 */

/**
		 * Returns the script element that is currently executing.
		 *
		 * This does __not__ work for line script element.
		 *
		 * @returns {HTMLScriptElement | null}
		 */

/**
		 * Returns whether a given class is active for `element`.
		 *
		 * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
		 * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
		 * given class is just the given class with a `no-` prefix.
		 *
		 * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
		 * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
		 * ancestors have the given class or the negated version of it, then the default activation will be returned.
		 *
		 * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
		 * version of it, the class is considered active.
		 *
		 * @param {Element} element
		 * @param {string} className
		 * @param {boolean} [defaultActivation=false]
		 * @returns {boolean}
		 */

/**
		 * Runs a hook invoking all registered callbacks with the given environment variables.
		 *
		 * Callbacks will be invoked synchronously and in the order in which they were registered.
		 *
		 * @param {string} name The name of the hook.
		 * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
		 * @public
		 */

/**
	 * @namespace
	 * @memberof Prism
	 * @public
	 */

/**
	 * A namespace for utility methods.
	 *
	 * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
	 * change or disappear at any time.
	 *
	 * @namespace
	 * @memberof Prism
	 */

/**
	 * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
	 * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
	 * additional languages or plugins yourself.
	 *
	 * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
	 *
	 * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
	 * empty Prism object into the global scope before loading the Prism script like this:
	 *
	 * ```js
	 * window.Prism = window.Prism || {};
	 * Prism.manual = true;
	 * // add a new <script> to load Prism's script
	 * ```
	 *
	 * @default false
	 * @type {boolean}
	 * @memberof Prism
	 * @public
	 */

/**
	 * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
	 * {@link Prism.highlightElement} on each one of them.
	 *
	 * The following hooks will be run:
	 * 1. `before-highlightall`
	 * 2. All hooks of {@link Prism.highlightElement} for each element.
	 *
	 * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
	 * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
	 * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
	 * @memberof Prism
	 * @public
	 */

/**
	 * Highlights the code inside a single element.
	 *
	 * The following hooks will be run:
	 * 1. `before-sanity-check`
	 * 2. `before-highlight`
	 * 3. All hooks of {@link Prism.highlight}. These hooks will only be run by the current worker if `async` is `true`.
	 * 4. `before-insert`
	 * 5. `after-highlight`
	 * 6. `complete`
	 *
	 * @param {Element} element The element containing the code.
	 * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
	 * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
	 * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
	 * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
	 *
	 * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
	 * asynchronous highlighting to work. You can build your own bundle on the
	 * [Download page](https://prismjs.com/download.html).
	 * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
	 * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
	 * @memberof Prism
	 * @public
	 */

/**
	 * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
	 * and the language definitions to use, and returns a string with the HTML produced.
	 *
	 * The following hooks will be run:
	 * 1. `before-tokenize`
	 * 2. `after-tokenize`
	 * 3. `wrap`: On each {@link Token}.
	 *
	 * @param {string} text A string with the code to be highlighted.
	 * @param {Grammar} grammar An object containing the tokens to use.
	 *
	 * Usually a language definition like `Prism.languages.markup`.
	 * @param {string} language The name of the language definition passed to `grammar`.
	 * @returns {string} The highlighted HTML.
	 * @memberof Prism
	 * @public
	 * @example
	 * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
	 */

/**
	 * The alias(es) of the token.
	 *
	 * @type {string|string[]}
	 * @see GrammarToken
	 * @public
	 */

/**
	 * The strings or tokens contained by this token.
	 *
	 * This will be a token stream if the pattern matched also defined an `inside` grammar.
	 *
	 * @type {string | TokenStream}
	 * @public
	 */

/**
	 * The type of the token.
	 *
	 * This is usually the key of a pattern in a {@link Grammar}.
	 *
	 * @type {string}
	 * @see GrammarToken
	 * @public
	 */

/**
	 * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
	 * and the language definitions to use, and returns an array with the tokenized code.
	 *
	 * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
	 *
	 * This method could be useful in other contexts as well, as a very crude parser.
	 *
	 * @param {string} text A string with the code to be highlighted.
	 * @param {Grammar} grammar An object containing the tokens to use.
	 *
	 * Usually a language definition like `Prism.languages.markup`.
	 * @returns {TokenStream} An array of strings and tokens, a token stream.
	 * @memberof Prism
	 * @public
	 * @example
	 * let code = `var foo = 0;`;
	 * let tokens = Prism.tokenize(code, Prism.languages.javascript);
	 * tokens.forEach(token => {
	 *     if (token instanceof Prism.Token && token.type === 'number') {
	 *         console.log(`Found numeric literal: ${token.content}`);
	 *     }
	 * });
	 */

/**
	 * This is the most high-level function in Prism’s API.
	 * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
	 * each one of them.
	 *
	 * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
	 *
	 * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
	 * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
	 * @memberof Prism
	 * @public
	 */

/**
	 * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
	 *
	 * @namespace
	 * @memberof Prism
	 * @public
	 */

/**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */

/**
 * @param {LinkedList<T>} list
 * @returns {T[]}
 * @template T
 */

/**
 * @param {string} text
 * @param {LinkedList<string | Token>} tokenList
 * @param {any} grammar
 * @param {LinkedListNode<string | Token>} startNode
 * @param {number} startPos
 * @param {RematchOptions} [rematch]
 * @returns {void}
 * @private
 *
 * @typedef RematchOptions
 * @property {string} cause
 * @property {number} reach
 */

/**
 * @template T
 * @private
 */

/**
 * @typedef LinkedListNode
 * @property {T} value
 * @property {LinkedListNode<T> | null} prev The previous node.
 * @property {LinkedListNode<T> | null} next The next node.
 * @template T
 * @private
 */

/**
 * A token stream is an array of strings and {@link Token Token} objects.
 *
 * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process
 * them.
 *
 * 1. No adjacent strings.
 * 2. No empty strings.
 *
 *    The only exception here is the token stream that only contains the empty string and nothing else.
 *
 * @typedef {Array<string | Token>} TokenStream
 * @global
 * @public
 */

/**
 * Adds a new node with the given value to the list.
 * @param {LinkedList<T>} list
 * @param {LinkedListNode<T>} node
 * @param {T} value
 * @returns {LinkedListNode<T>} The added node.
 * @template T
 */

/**
 * Converts the given token or token stream to an HTML representation.
 *
 * The following hooks will be run:
 * 1. `wrap`: On each {@link Token}.
 *
 * @param {string | Token | TokenStream} o The token or token stream to be converted.
 * @param {string} language The name of current language.
 * @returns {string} The HTML representation of the token or token stream.
 * @memberof Token
 * @static
 */

/**
 * Creates a new token.
 *
 * @param {string} type See {@link Token#type type}
 * @param {string | TokenStream} content See {@link Token#content content}
 * @param {string|string[]} [alias] The alias(es) of the token.
 * @param {string} [matchedStr=""] A copy of the full string this token was created from.
 * @class
 * @global
 * @public
 */

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */

/**
 * Removes `count` nodes after the given node. The given node will not be removed.
 * @param {LinkedList<T>} list
 * @param {LinkedListNode<T>} node
 * @param {number} count
 * @template T
 */

/** @type {Array} */

/** @type {Grammar} */

/** @type {LinkedListNode<T>} */

/** @type {Record<string, any>} */

/** @type {RegExp} */

/** @type {any} */

/***/

//

//    at Global code (http://localhost/components/prism-core.js:606:1)

//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)

//   @typedef {InstanceType<import("./prism-core")["Token"]>} Token

//  '.'

//  ';'

// (inclusive).

// @flow

// A stack will look like this:

// ASCII digits.

// ASCII hex digits.

// Accept `boolean` and `string`.

// Accept `object` on style.

// All non-terminated numeric entities are not rendered, and trigger a

// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)

// Allow for two levels of nesting

// An ampersand followed by anything unknown, and not terminated, is

// An empty (possible) entity is valid, unless it’s numeric (thus an

// And merge text with adjacent text

// Attribute or property.

// CONCATENATED MODULE: ./node_modules/react-syntax-highlighter/dist/esm/checkForListedLanguage.js

// CONCATENATED MODULE: ./node_modules/react-syntax-highlighter/dist/esm/create-element.js

// CONCATENATED MODULE: ./node_modules/react-syntax-highlighter/dist/esm/highlight.js

// Cache the current point.

// Check if `character` is disallowed.

// Check if `character` is outside the permissible unicode range.

// Check if the given character code, or the character code at the first

// Check if we can match a legacy named reference.

// Class-names (which can be added both on the `selector` and here).

// Closing tag

// Compile an array to comma-separated tokens.

// Construct.

// Converted automatically using ./tools/themeFromVsCode

// Copy of the full string this token was created from

// Create a hast element from a simple CSS selector.

// Create.

// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they

// Do not duplicate registrations.

// Do not insert token which also occur in insert. See #1525

// Does nothing when `queue` is empty.

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js

// EXTERNAL MODULE: ./node_modules/refractor/core.js

// Ensure the algorithm walks over the first character and the end

// Ensure the last empty entry is seen.

// Error

// Expose.

// Find language

// First eat the queued characters as normal text, then eat an entity.

// Flush `queue` (normal text).

// Found it!

// Get current position.

// Get current script and highlight

// Get file src url from stack. Specifically works with the format of stack traces in IE.

// Handle anything other than an ampersand, including newlines and EOF.

// Handle list values.

// Here we are inside a tag, and not inside a JSX context.

// Here we might have entered a JSX context inside a tag

// Here we might have left a JSX context inside a tag

// Hyperscript compatible DSL for creating virtual hast trees.

// IE11 workaround

// If so, we cache that as the last viable named reference.

// If the decoded string is equal to the input, the entity was not valid

// If the document state is "interactive" and the prism.js script is deferred, then we'll also use the

// If the document state is "loading", then we'll use DOMContentLoaded.

// If the previous character was a newline.

// If the reference is not terminated, warn.

// If theres something after an entity name which is not known, cap

// If we could not find a reference, queue the checked characters (as

// Ignore nully and NaN values.

// In worker

// Inherit.

// Legacy.

// Lists. Use CSS to reduce space between items instead

// Load all stuff in `prism.js` itself, except for `prism-file-highlight.js`.

// Macro invoked before each entity and at the end of `value`.

// Named entity.

// No characters are consumed, and nothing is returned.

// Non-standard Properties.

// Not a character reference.

// Numerical entity.

// Opening tag

// Parse a (list of) primitives.

// Parse a single primitives.

// Parse comma-separated tokens to an array.

// Parse entities.

// Parse the number.

// Plugin to make entity title show the real entity, idea by Roman Komarov

// Pop matching opening tag

// Private helper vars

// Register bundled grammars.

// Return the reduced nodes.

// See https://github.com/PrismJS/prism/issues/2102

// See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis

// Set language on the element, if not present

// Set language on the parent, for styling

// Several table elements. When `align=char`, sets the character to align on

// Several table elements. When `char`, offsets the alignment

// Several. Use CSS `text-align` instead,

// Several. Use CSS `vertical-align` instead

// Some entities do not require the closing semicolon (`&not` - for instance),

// Something went terribly wrong, ABORT, ABORT!

// Standard Properties.

// Stringify the number.

// That's plain text: drop any tokens matched.

// The behaviour depends on the identity of the next character.

// The behaviour further depends on the next character.

// The following can be used to import the Token type in JSDoc:

// The following will handle plain text inside tags

// The wrapped non-leaky grammars are loaded instead of Prism’s originals.

// This ensures we do not need to walk backwards later.

// This is not an error, either.

// This is possible because we can be certain neither newlines nor

// This must be declared before keyword because we use "function" inside the look-forward

// Traverse a language definition with Depth First Search

// Trigger a warning when the parsed number is disallowed, and replace

// Trigger a warning when the parsed number is prohibited, and replace

// Trigger a warning when the parsed number should not be used.

// Typescript note:

// Update references in other language definitions

// Warning types.

// We found a tag, now find its kind

// When terminated and number, parse as either hexadecimal or decimal.

// Without the global flag, lastIndex won't work

// Wrap `handleWarning`.

// Wrap to ensure clean parameters are given to `parse`.

// `<applet>`

// `<area>`. Use no href instead of an explicit `nohref`

// `<body>`

// `<body>` and table elements. Use CSS `background-color` instead

// `<body>`. Use CSS `a:active {color}` instead

// `<body>`. Use CSS `a:link {color: *}` instead

// `<body>`. Use CSS `a:visited {color}` instead

// `<body>`. Use CSS `background-image` instead

// `<body>`. Use CSS `color` instead

// `<br>`. Use CSS `clear` instead

// `<font>` and `<hr>`. Use CSS instead

// `<font>`. Use CSS instead

// `<frame>`

// `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`

// `<frame>`. Use overflow in the child context

// `<head>`

// `<hr>`. Use background-color and height instead of borders

// `<html>`. Use a doctype.

// `<iframe>`. Use CSS `border` instead

// `<img>` and `<object>`

// `<img>`. Use a `<picture>`

// `<isindex>`

// `<link>`

// `<meta>`

// `<object>`

// `<object>`. List of URIs to archives

// `<param>`

// `<script>`

// `<table>`

// `<table>`. Use CSS `border-color` instead,

// `<table>`. Use CSS `border-width` instead,

// `<td>` and `<th>`

// `<td>` and `<th>`. Use `scope` on `<th>`

// `name` is a grammar object.

// `options.padLeft` (default: `true`) pads a space left of each token, and

// `options.padRight` (default: `false`) pads a space to the right of each token.

// adjust pos (and p)

// ampersand followed by an octothorp).

// ampersands are included.

// assume that the matching was incomplete

// assumes that node != list.tail && values.length >= 0

// at least one Token object was removed, so we have to do some rematching

// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.

// by an alternative.

// character, is alphabetical.

// character, is alphanumerical.

// character, is decimal.

// character, is hexadecimal.

// determine largest line number so that we can force minWidth on all linenumber elements

// eslint-disable-next-line complexity

// eslint-disable-next-line max-depth

// figure out whether we're using lowlight/highlight or refractor/prism

// find the last node which is affected by this match

// find the node that contains the match

// hack for components to work correctly in node.js

// https://drafts.csswg.org/css-values-3/#urls

// https://www.w3.org/TR/xml/#NT-doctypedecl

// if it's neither the first nor the last line

// if it's the first line

// invalid.

// istanbul ignore next - Don't allow Prism to run on page load in browser or

// lowlight/highlight?

// might take longer one animation frame to execute which can create a race condition where only some plugins have

// minimally necessary styling for line numbers

// must be refractor/prism, then

// normal characters), and move the pointer to their end.

// only highlight.js has the highlightAuto method

// parsing and the entity to decode was not a semicolon (`&semi;`), we can

// prep custom styling

// replace with the new match

// result in the string `¬it;`.  When we encounter a trailing semicolon after

// the current node is a Token, then the match starts inside another Token, which is invalid

// the reference.

// then attempt highlighting accordingly

// this can only happen if the current pattern is greedy

// this is the to parameter of removeBetween

// this will not work for inline scripts

// to start messaging from workers.

// warning.

// we'll get the src of the current script by parsing IE11's error stack trace

// which leads to situations where parsing the assumed entity of &notit; will

// with replacement character.

// “Throw” a parse-error: a warning.

/// <reference lib="WebWorker"/>
