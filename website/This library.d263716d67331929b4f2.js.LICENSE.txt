/*
              * aria-rowindex is counted from 1 according to w3c spec;
              * parseInt with radix is 2x faster, then +, -, etc.
                  https://jsperf.com/number-vs-parseint-vs-plus/116
          */

/*
            Some benchmarks inspire me to use nextElementSibling
            https://jsperf.com/nextsibling-vs-childnodes-increment/2
        */

/*
            using target.offsetWidth instead of contentRect.width, because we need border-box sizing, 
            and { box: border-box } option does not work here
        */

/*
          Trees are not always ideally allocated, gaps are possible.
          Classical way for calculating parents is much simpler,
          but can do much more work(summing zeros) in such conditions. Commented classic algo:
                        for( let i = N + visibleRowCount >> 1, j; i > 0; --i ){
              j = i << 1;
              sTree[ i ] = sTree[ j ] + sTree[ j | 1 ];
          }
      */

/*
          When all row heights are different,
          we must "predict" them on the left of startIndex and on the right of endIndex(where they are invisible),
          basing on what we know: heights between startIndex and endIndex.
          Using simple average by default.
      */

/*
          getVisibleRangeStart works by "strict less" algo. It is good for startIndex,
          but for endIndex we need "<=", so adding 1 artificially.
      */

/*
      Column heights may change during scroll/width-change
  */

/*
      For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.
      If RowComponent should be wrapped my mobx observer - non-memo version should be imported.
      memo(observer(RowComponentDefault)) will do the trick.
  */

/*
      Hmm, I can't put here more than ~ 3 000 000. Maybe need to put one more row in case this height is > 3 000 000
  */

/*
      tabIndex="0" is for proper keyboard nav
      https://bugzilla.mozilla.org/show_bug.cgi?id=1346159
  */

/*   increaseEndIndexIfNeededSync(){
         const currentVisibleDist = this.getDistanceBetweenIndexes( this.startIndex, this.endIndex );
         if( this.widgetHeight > this.virtualTopOffset + currentVisibleDist - this.scrollTop ){
             this.updateEndIndex();
         }
     }
  
     increaseEndIndexIfNeeded = debounce( this.increaseEndIndexIfNeededSync, END_INDEX_CHECK_INTERVAL );
  */

/* If we do this via transform translate, col background would have bugs during horizontal scroll. Strange webkit behavior */

/* In segments tree 1 node is always sum of all elements */

/* Nearest pow of 2 to visibleRowCount. 56 >= 64, 67 => 128, etc. */

/* avoiding double destructurization via getExtraProps, so making prop object once */

/* callback ref */

/* harmony default export */

/* harmony export (binding) */

/* harmony import */

/* if( sort && sort.dataKey ){
           const { dataKey, value } = sort;
           const { getCellData, getRowData } = parent;
           const col = columnsByDataKey[ dataKey ];
           const fn = col.getCellData || getCellData;
           const sign = value === "ascending" ? 1 : -1;
           return mapValues( this.grouped, v => v.sort(( a, b ) => {
               const row1 = getRowData( a );
               const row2 = getRowData( b );
               if( !row1 || !row2 ){
                   return 0;
               }
               const cell1 = fn( row1, a, dataKey );
               const cell2 = fn( row2, b, dataKey );
               if( cell1 > cell2 ){
                   return sign;
               }
               if( cell1 < cell2 ){
                   return -sign;
               }
               return 0;
           }));
       }*/

/* multilevel grouping */

/*#__PURE__*/

/***/

//    For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.

//    If RowComponent should be wrapped my mobx observer - non-memo version should be imported.

//    memo(observer(RowComponentDefault)) will do the trick.

// CONCATENATED MODULE: ./lib/Table/common/Rows.js

// CONCATENATED MODULE: ./lib/Table/common/Tfoot.js

// EXTERNAL MODULE: ./lib/Table/common/Cell.js

// EXTERNAL MODULE: ./lib/common/RowCountWarningContainer.js

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js

// EXTERNAL MODULE: ./node_modules/mobx-react-lite/dist/mobxreactlite.esm.js

// console.log( "%d| was: %d; is: %d", index, sTree[N+index],newHeight)

// extracted by mini-css-extract-plugin

// this.increaseEndIndexIfNeeded.cancel();

//superdirty
