{"version":3,"sources":["webpack:///./lib/models/ScrollableRowsBase.js","webpack:///./lib/models/VariableSizeScrollableRows.js","webpack:///./lib/models/FixedSizeScrollableRows.js","webpack:///./lib/Context.js","webpack:///./lib/utils/useStore/index.js","webpack:///./lib/models/RowsSimple.js","webpack:///./lib/models/createList.js","webpack:///./lib/models/VariableSizeList.js","webpack:///./lib/models/FixedSizeList.js","webpack:///./lib/utils/cx/index.js","webpack:///./lib/useApi/index.js","webpack:///./lib/common/HeightProvider.js","webpack:///./lib/common/ScrollContainer.js","webpack:///./lib/utils/extraPropsGetters/index.js","webpack:///./lib/List/common/Row.js","webpack:///./lib/List/common/Rows.js","webpack:///./lib/common/Scroller.js","webpack:///./lib/commonDefaultProps.js","webpack:///./lib/List/index.js"],"names":["_class","createContext","useStore","StoreConstructor","dataRef","propsToMerge","scrollContainerRef","useRef","rowsContainerRef","finalDataRef","Store","current","useLayoutEffect","merge","Object","assign","rowsContainerNode","scrollContainerNode","useEffect","destructor","RowsSimple","parent","this","_createClass","key","get","rows","length","createList","BaseClass","_BaseClass","call","_inheritsLoose","BASIC_OBSERVABLE_FIELDS","overscanRowsCount","estimatedRowHeightFallback","scrollLeft","scrollTop","widgetHeight","widgetWidth","getRowKey","undefined","getRowData","Error","ScrollableRowsBase","_proto","prototype","RowsConstructor","Rows","extendObservable","observable","ref","params","getVisibleRangeStart","estimatedRowHeight","newVisibleStartIndex","visibleRangeStart","Math","max","newEndIndex","min","visibleRowCount","_this$visibleRangeSta2","remainder","overscanOffset","getDistanceBetweenIndexes","startIndex","scrollToRow","index","node","clamp","scrollToStart","_applyDecoratedDescriptor","computed","getOwnPropertyDescriptor","action","_ScrollableRowsBase","VariableSizeScrollableRows","_this","rowsDomObserver","MutationObserver","runInAction","lastRowsRenderTimeStamp","performance","now","disposeCallbacks","_assertThisInitialized","widgetScrollHeight","shouldResetInvisibleRowHeights","push","reaction","h","fireImmediately","autorun","_assertThisInitialize","_assertThisInitialize2","sTree","N","fill","calculateParentsInRange","delay","disconnect","observe","childList","subtree","newHeight","_assertThisInitialize3","l","r","rowHeightsSum","rowCounter","child","firstElementChild","nextElementSibling","parseInt","getAttribute","offsetHeight","round","endIndex","i","dist","v","nodeIndex","log2","Uint32Array","forEach","cb","res","FixedSizeScrollableRows","apply","arguments","distance","set","value","cx","baseClass","extraClass","useApi","useContext","Context","el","React","createElement","className","observer","cloneElement","style","height","ScrollContainer","forwardRef","_ref","children","onScroll","props","_objectWithoutPropertiesLoose","API","scrollHandler","useCallback","e","_e$target","target","R","ResizeObserver","entries","_entries$0$target","offsetWidth","unobserve","_extends","tabIndex","HeightProvider","getPropsGetter","propName","data","dataIndex","getExtraProps","_props","extraProps","getRowProps","Row","getRowExtraProps","rowIndex","rowData","propTypes","RowComponent","_useApi","rangeFrom","rangeTo","rowKey","result","getVisibleRows","Component","virtualTopOffset","commonDefaultProps","fixedSize","List","_ref$RowComponent","RowComponentDefault","_useStore","FixedSizeListStore","VariableSizeListStore","Provider","Scroller","defaultProps","memo"],"mappings":"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","file":"This library.4aaaf736405b10fa57cb.js","sourcesContent":["import _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\n\nvar _class;\n\nimport { extendObservable, computed, action, observable } from \"mobx\";\nimport clamp from \"lodash/clamp\";\n\nvar getRowDataInitial = function getRowDataInitial() {\n  throw new Error(\"getRowData must be provided\");\n};\n\nvar BASIC_OBSERVABLE_FIELDS = {\n  rows: {\n    length: 0\n  },\n  overscanRowsCount: 0,\n  estimatedRowHeightFallback: 0,\n  scrollLeft: 0,\n  scrollTop: 0,\n  widgetHeight: 0,\n  widgetWidth: 0,\n  getRowKey: undefined,\n  getRowData: getRowDataInitial,\n  rowsContainerNode: null,\n  scrollContainerNode: null\n};\nvar END_INDEX_CHECK_INTERVAL = 400;\nvar ScrollableRowsBase = (_class = /*#__PURE__*/function () {\n  var _proto = ScrollableRowsBase.prototype;\n\n  _proto.merge = function merge(params) {\n    Object.assign(this, params);\n  };\n\n  _createClass(ScrollableRowsBase, [{\n    key: \"visibleRangeStart\",\n    get: function get() {\n      return this.getVisibleRangeStart(this.scrollTop);\n    }\n  }, {\n    key: \"startIndex\",\n    get: function get() {\n      if (!this.estimatedRowHeight) {\n        return 0;\n      }\n\n      var _this$visibleRangeSta = this.visibleRangeStart,\n          newVisibleStartIndex = _this$visibleRangeSta[0];\n      return Math.max(0, newVisibleStartIndex - this.overscanRowsCount);\n    }\n  }, {\n    key: \"endIndex\",\n    get: function get() {\n      if (!this.estimatedRowHeight) {\n        return 0;\n      }\n\n      var _this$getVisibleRange = this.getVisibleRangeStart(this.scrollTop + this.widgetHeight),\n          newEndIndex = _this$getVisibleRange[0];\n      /*\r\n          getVisibleRangeStart works by \"strict less\" algo. It is good for startIndex,\r\n          but for endIndex we need \"<=\", so adding 1 artificially.\r\n      */\n\n\n      return Math.min(newEndIndex + 1 + this.overscanRowsCount, this.Rows.visibleRowCount);\n    }\n  }, {\n    key: \"virtualTopOffset\",\n    get: function get() {\n      var _this$visibleRangeSta2 = this.visibleRangeStart,\n          newVisibleStartIndex = _this$visibleRangeSta2[0],\n          remainder = _this$visibleRangeSta2[1];\n      var overscanOffset = this.getDistanceBetweenIndexes(this.startIndex, newVisibleStartIndex);\n      return this.scrollTop - remainder - overscanOffset;\n    }\n  }]);\n\n  function ScrollableRowsBase(RowsConstructor) {\n    this.Rows = new RowsConstructor(this);\n    extendObservable(this, BASIC_OBSERVABLE_FIELDS, {\n      rowsContainerNode: observable.ref,\n      scrollContainerNode: observable.ref\n    });\n    /*\r\n    this\r\n        .on( \"#widgetScrollHeight\", this.increaseEndIndexIfNeeded )\r\n        .on( \"#endIndex\", this.increaseEndIndexIfNeeded.cancel );\r\n    */\n  }\n  /*\r\n      Column heights may change during scroll/width-change\r\n  */\n\n  /*   increaseEndIndexIfNeededSync(){\r\n         const currentVisibleDist = this.getDistanceBetweenIndexes( this.startIndex, this.endIndex );\r\n         if( this.widgetHeight > this.virtualTopOffset + currentVisibleDist - this.scrollTop ){\r\n             this.updateEndIndex();\r\n         }\r\n     }\r\n  \n     increaseEndIndexIfNeeded = debounce( this.increaseEndIndexIfNeededSync, END_INDEX_CHECK_INTERVAL );\r\n  */\n\n\n  _proto.destructor = function destructor() {// this.increaseEndIndexIfNeeded.cancel();\n  };\n\n  _proto.scrollToRow = function scrollToRow(index) {\n    var node = this.scrollContainerNode;\n\n    if (node) {\n      node.scrollTop = this.getDistanceBetweenIndexes(0, clamp(index, 0, this.Rows.visibleRowCount));\n    }\n\n    return this;\n  };\n\n  _proto.scrollToStart = function scrollToStart() {\n    return this.scrollToRow(0);\n  };\n\n  return ScrollableRowsBase;\n}(), (_applyDecoratedDescriptor(_class.prototype, \"visibleRangeStart\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"visibleRangeStart\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"startIndex\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"startIndex\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"endIndex\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"endIndex\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"virtualTopOffset\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"virtualTopOffset\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"merge\", [action], Object.getOwnPropertyDescriptor(_class.prototype, \"merge\"), _class.prototype)), _class);\n;\nexport default ScrollableRowsBase;","import _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\n\nvar _class, _temp;\n\nimport ScrollableRowsBase from \"./ScrollableRowsBase\";\nimport { observable, extendObservable, computed, autorun, action, runInAction, reaction } from \"mobx\";\n/*\r\n    We should always have some extra space for new rows. We do not want to reallocate cache every time.\r\n*/\n\nvar MIN_TREE_CACHE_OFFSET = 15;\nvar ROW_MEASUREMENT_DEBOUNCE_INTERVAL = 200;\nvar VariableSizeScrollableRows = (_class = (_temp = /*#__PURE__*/function (_ScrollableRowsBase) {\n  _inheritsLoose(VariableSizeScrollableRows, _ScrollableRowsBase);\n\n  var _proto = VariableSizeScrollableRows.prototype;\n\n  _proto.calculateParentsInRange = function calculateParentsInRange(startIndex, endIndex) {\n    var sTree = this.sTree,\n        N = this.N;\n\n    for (endIndex += N, startIndex += N; endIndex >>= 1;) {\n      for (var i = startIndex >>= 1; i <= endIndex; i++) {\n        sTree[i] = sTree[i << 1] + sTree[i << 1 | 1];\n      }\n    }\n    /* In segments tree 1 node is always sum of all elements */\n\n\n    this.merge({\n      widgetScrollHeight: sTree[1]\n    });\n  };\n\n  _proto.getVisibleRangeStart = function getVisibleRangeStart(dist) {\n    var widgetScrollHeight = this.widgetScrollHeight,\n        estimatedRowHeight = this.estimatedRowHeight,\n        sTree = this.sTree,\n        N = this.N;\n\n    if (widgetScrollHeight && estimatedRowHeight) {\n      var nodeIndex = 1,\n          v;\n\n      while (nodeIndex < N) {\n        v = sTree[nodeIndex <<= 1];\n\n        if (dist >= v) {\n          dist -= v;\n          nodeIndex |= 1;\n        }\n      }\n\n      return [nodeIndex - N, dist];\n    }\n\n    return [0, 0];\n  };\n\n  _createClass(VariableSizeScrollableRows, [{\n    key: \"N\",\n    get: function get() {\n      /* Nearest pow of 2 to visibleRowCount. 56 >= 64, 67 => 128, etc. */\n      var visibleRowCount = this.Rows.visibleRowCount;\n      return visibleRowCount > 0 ? 2 << Math.log2(visibleRowCount + MIN_TREE_CACHE_OFFSET) : 1;\n    }\n  }, {\n    key: \"sTree\",\n    get: function get() {\n      // Uint16 cannot be used here, because array stores intermediate sums, which can be huge.\n      if (process.env.NODE_ENV !== \"production\") {\n        console.log(\"New tree cache. Size:\", this.N);\n      }\n\n      return new Uint32Array(this.N << 1);\n    }\n  }]);\n\n  function VariableSizeScrollableRows(RowsConstructor) {\n    var _this;\n\n    _this = _ScrollableRowsBase.call(this, RowsConstructor) || this;\n    _this.rowsDomObserver = new MutationObserver(function () {\n      return runInAction(function () {\n        _this.lastRowsRenderTimeStamp = performance.now();\n      });\n    });\n    _this.disposeCallbacks = [];\n    extendObservable(_assertThisInitialized(_this), {\n      estimatedRowHeight: 0,\n      widgetScrollHeight: 0,\n      lastRowsRenderTimeStamp: 0,\n\n      /*\r\n          When all row heights are different,\r\n          we must \"predict\" them on the left of startIndex and on the right of endIndex(where they are invisible),\r\n          basing on what we know: heights between startIndex and endIndex.\r\n          Using simple average by default.\r\n      */\n      shouldResetInvisibleRowHeights: true\n    });\n\n    _this.disposeCallbacks.push(reaction(function () {\n      return _this.estimatedRowHeightFallback;\n    }, function (h) {\n      if (!_this.estimatedRowHeight) {\n        _this.estimatedRowHeight = h;\n      }\n    }, {\n      fireImmediately: true\n    }), autorun(function () {\n      var _assertThisInitialize = _assertThisInitialized(_this),\n          rows = _assertThisInitialize.rows,\n          estimatedRowHeight = _assertThisInitialize.estimatedRowHeight; //superdirty\n\n\n      if (!estimatedRowHeight || !rows) {\n        return;\n      }\n\n      var _assertThisInitialize2 = _assertThisInitialized(_this),\n          sTree = _assertThisInitialize2.sTree,\n          N = _assertThisInitialize2.N,\n          visibleRowCount = _assertThisInitialize2.Rows.visibleRowCount;\n      /* todo: optimize this shit by using visibleRowCount */\n\n\n      sTree.fill(estimatedRowHeight, 0, N * 2);\n      /*\r\n          Trees are not always ideally allocated, gaps are possible.\r\n          Classical way for calculating parents is much simpler,\r\n          but can do much more work(summing zeros) in such conditions. Commented classic algo:\r\n                        for( let i = N + visibleRowCount >> 1, j; i > 0; --i ){\r\n              j = i << 1;\r\n              sTree[ i ] = sTree[ j ] + sTree[ j | 1 ];\r\n          }\r\n      */\n\n      _this.calculateParentsInRange(0, visibleRowCount);\n    }), autorun(function () {\n      if (_this.widgetWidth) {\n        _this.merge({\n          shouldResetInvisibleRowHeights: true\n        });\n      }\n    }, {\n      delay: 200\n    }), autorun(function () {\n      _this.rowsDomObserver.disconnect();\n\n      if (_this.rowsContainerNode) {\n        _this.rowsDomObserver.observe(_this.rowsContainerNode, {\n          childList: true,\n          subtree: true\n        });\n      }\n    }), autorun(function () {\n      var node = _this.rowsContainerNode;\n\n      if (node && _this.lastRowsRenderTimeStamp) {\n        var _assertThisInitialize3 = _assertThisInitialized(_this),\n            sTree = _assertThisInitialize3.sTree,\n            N = _assertThisInitialize3.N;\n\n        var l = -1,\n            r = -1,\n            rowHeightsSum = 0,\n            rowCounter = 0;\n        /*\r\n            Some benchmarks inspire me to use nextElementSibling\r\n            https://jsperf.com/nextsibling-vs-childnodes-increment/2\r\n        */\n\n        for (var child = node.firstElementChild, newHeight, index; child; child = child.nextElementSibling, rowCounter++) {\n          /*\r\n              * aria-rowindex is counted from 1 according to w3c spec;\r\n              * parseInt with radix is 2x faster, then +, -, etc.\r\n                  https://jsperf.com/number-vs-parseint-vs-plus/116\r\n          */\n          index = parseInt(child.getAttribute(\"aria-rowindex\"), 10) - 1;\n\n          if (process.env.NODE_ENV !== \"production\" && Number.isNaN(index)) {\n            throw new Error(\"aria-rowindex attribute must be present on each row. Look at default Row implementations.\");\n          }\n\n          newHeight = child.offsetHeight;\n          rowHeightsSum += newHeight;\n\n          if (sTree[N + index] !== newHeight) {\n            // console.log( \"%d| was: %d; is: %d\", index, sTree[N+index],newHeight)\n            sTree[N + index] = newHeight;\n\n            if (l === -1) {\n              l = index;\n            }\n\n            r = index;\n          }\n        }\n\n        if (l !== -1) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.log(\"Updating heights in range: %d - %d\", l, r);\n          }\n\n          if (_this.shouldResetInvisibleRowHeights) {\n            _this.merge({\n              estimatedRowHeight: Math.round(rowHeightsSum / rowCounter),\n              shouldResetInvisibleRowHeights: false\n            });\n          } else {\n            _this.calculateParentsInRange(l, r);\n          }\n        }\n      }\n    }, {\n      delay: ROW_MEASUREMENT_DEBOUNCE_INTERVAL\n    }));\n\n    return _this;\n  }\n\n  _proto.destructor = function destructor() {\n    this.disposeCallbacks.forEach(function (cb) {\n      return cb();\n    });\n\n    _ScrollableRowsBase.prototype.destructor.call(this);\n  };\n\n  _proto.getDistanceBetweenIndexes = function getDistanceBetweenIndexes(startIndex, endIndex) {\n    if (!this.estimatedRowHeight) {\n      return 0;\n    }\n\n    var sTree = this.sTree,\n        N = this.N;\n    var res = 0;\n\n    for (startIndex += N, endIndex += N; startIndex < endIndex; startIndex >>= 1, endIndex >>= 1) {\n      if (startIndex & 1) {\n        res += sTree[startIndex++];\n      }\n\n      if (endIndex & 1) {\n        res += sTree[--endIndex];\n      }\n    }\n\n    ;\n    return res;\n  };\n\n  return VariableSizeScrollableRows;\n}(ScrollableRowsBase), _temp), (_applyDecoratedDescriptor(_class.prototype, \"N\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"N\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"sTree\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"sTree\"), _class.prototype)), _class);\n;\nexport default VariableSizeScrollableRows;","import _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\n\nvar _class;\n\nimport { computed } from \"mobx\";\nimport ScrollableRowsBase from \"./ScrollableRowsBase\";\nvar FixedSizeScrollableRows = (_class = /*#__PURE__*/function (_ScrollableRowsBase) {\n  _inheritsLoose(FixedSizeScrollableRows, _ScrollableRowsBase);\n\n  function FixedSizeScrollableRows() {\n    return _ScrollableRowsBase.apply(this, arguments) || this;\n  }\n\n  var _proto = FixedSizeScrollableRows.prototype;\n\n  _proto.getVisibleRangeStart = function getVisibleRangeStart(distance) {\n    var estimatedRowHeight = this.estimatedRowHeight;\n    return estimatedRowHeight ? [distance / estimatedRowHeight | 0, distance % estimatedRowHeight] : [0, 0];\n  };\n\n  _proto.getDistanceBetweenIndexes = function getDistanceBetweenIndexes(startIndex, endIndex) {\n    return this.estimatedRowHeight * (endIndex - startIndex);\n  };\n\n  _createClass(FixedSizeScrollableRows, [{\n    key: \"estimatedRowHeight\",\n    get: function get() {\n      if (this.widgetWidth) {\n        var node = this.rowsContainerNode;\n\n        if (node) {\n          var firstElementChild = node.firstElementChild;\n\n          if (firstElementChild) {\n            return firstElementChild.offsetHeight;\n          }\n        }\n      }\n\n      return this.estimatedRowHeightFallback;\n    },\n    set: function set(value) {\n      this.estimatedRowHeightFallback = value;\n    }\n  }, {\n    key: \"widgetScrollHeight\",\n    get: function get() {\n      return this.estimatedRowHeight * this.Rows.visibleRowCount;\n    }\n  }]);\n\n  return FixedSizeScrollableRows;\n}(ScrollableRowsBase), (_applyDecoratedDescriptor(_class.prototype, \"estimatedRowHeight\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"estimatedRowHeight\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"widgetScrollHeight\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"widgetScrollHeight\"), _class.prototype)), _class);\n;\nexport default FixedSizeScrollableRows;","import { createContext } from \"react\";\nexport default /*#__PURE__*/createContext();","import { useRef, useEffect, useLayoutEffect } from \"react\";\n/*\r\n    dataRef is to call Data methods from outside( Data.scrollTo(), etc. ).\r\n    As it is not dom-related, I decided to avoid forwardRef\r\n*/\n\nvar useStore = function useStore(StoreConstructor, dataRef, propsToMerge) {\n  var scrollContainerRef = useRef();\n  var rowsContainerRef = useRef();\n  var finalDataRef = useRef();\n  var Store = finalDataRef.current;\n\n  if (!Store || !(Store instanceof StoreConstructor)) {\n    Store = finalDataRef.current = new StoreConstructor();\n  }\n\n  if (dataRef) {\n    dataRef.current = Store;\n  }\n\n  useLayoutEffect(function () {\n    Store.merge(Object.assign({}, propsToMerge, {\n      rowsContainerNode: rowsContainerRef.current,\n      scrollContainerNode: scrollContainerRef.current\n    }));\n  });\n  useEffect(function () {\n    return function () {\n      Store.destructor();\n    };\n  }, [Store]);\n  return [Store, scrollContainerRef, rowsContainerRef];\n};\n\nexport default useStore;","import _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { computed } from \"mobx\";\nimport groupBy from \"lodash/groupBy\";\nimport keyBy from \"lodash/keyBy\";\nimport times from \"lodash/times\";\n\nvar RowsSimple = /*#__PURE__*/function () {\n  function RowsSimple(parent) {\n    this.parent = parent;\n  }\n\n  _createClass(RowsSimple, [{\n    key: \"visibleRowCount\",\n    get: function get() {\n      return this.parent.rows.length;\n    }\n  }]);\n\n  return RowsSimple;\n}();\n\nexport default RowsSimple;","import _inheritsLoose from \"@babel/runtime/helpers/esm/inheritsLoose\";\nimport RowsSimple from \"./RowsSimple\";\n\nvar createList = function createList(BaseClass) {\n  return /*#__PURE__*/function (_BaseClass) {\n    _inheritsLoose(_class, _BaseClass);\n\n    function _class() {\n      return _BaseClass.call(this, RowsSimple) || this;\n    }\n\n    return _class;\n  }(BaseClass);\n};\n\nexport default createList;","import createList from \"./createList\";\nimport VariableSizeScrollableRows from \"./VariableSizeScrollableRows\";\nexport default createList(VariableSizeScrollableRows);","import createList from \"./createList\";\nimport FixedSizeScrollableRows from \"./FixedSizeScrollableRows\";\nexport default createList(FixedSizeScrollableRows);","var cx = function cx(baseClass, extraClass) {\n  return extraClass ? baseClass + \" \" + extraClass : baseClass;\n};\n\nexport default cx;","import { useContext } from \"react\";\nimport Context from \"../Context\";\n\nvar useApi = function useApi() {\n  return useContext(Context);\n};\n\nexport default useApi;","import React, { cloneElement } from \"react\";\nimport useApi from \"../useApi\";\nimport { observer } from \"mobx-react-lite\";\nvar el = /*#__PURE__*/React.createElement(\"div\", {\n  \"aria-hidden\": \"true\",\n  className: \"afvscr-height-provider\"\n});\n\nvar HeightProvider = function HeightProvider() {\n  return /*#__PURE__*/cloneElement(el, {\n    style: {\n      height: useApi().widgetScrollHeight\n    }\n  });\n};\n\nexport default observer(HeightProvider);","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React, { forwardRef, useCallback, useEffect } from \"react\";\nimport cx from \"../utils/cx\";\nimport HeightProvider from \"./HeightProvider\";\nimport useApi from \"../useApi\";\nvar ScrollContainer = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var className = _ref.className,\n      children = _ref.children,\n      onScroll = _ref.onScroll,\n      props = _objectWithoutPropertiesLoose(_ref, [\"className\", \"children\", \"onScroll\"]);\n\n  var API = useApi();\n  var scrollHandler = useCallback(function (e) {\n    var _e$target = e.target,\n        scrollTop = _e$target.scrollTop,\n        scrollLeft = _e$target.scrollLeft;\n    API.merge({\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    });\n\n    if (onScroll) {\n      onScroll(e);\n    }\n  }, [onScroll]);\n  useEffect(function () {\n    var el = ref.current;\n    var R = new ResizeObserver(function (entries) {\n      if (entries.length === 1) {\n        /*\r\n            using target.offsetWidth instead of contentRect.width, because we need border-box sizing, \r\n            and { box: border-box } option does not work here\r\n        */\n        var _entries$0$target = entries[0].target,\n            offsetWidth = _entries$0$target.offsetWidth,\n            offsetHeight = _entries$0$target.offsetHeight;\n        API.merge({\n          widgetHeight: Math.round(offsetHeight),\n          widgetWidth: Math.round(offsetWidth)\n        });\n      }\n    });\n    R.observe(el);\n    return function () {\n      R.unobserve(el);\n    };\n  }, []);\n  /*\r\n      tabIndex=\"0\" is for proper keyboard nav\r\n      https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\r\n  */\n\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    tabIndex: \"0\",\n    className: cx(\"afvscr-scroll-container\", className),\n    ref: ref,\n    onScroll: scrollHandler\n  }, props), /*#__PURE__*/React.createElement(HeightProvider, null), children);\n});\nexport default ScrollContainer;","var getPropsGetter = function getPropsGetter(propName) {\n  return function (data, index, dataIndex, getExtraProps) {\n    var _props;\n\n    /* avoiding double destructurization via getExtraProps, so making prop object once */\n    var props = (_props = {}, _props[propName] = index + 1, _props);\n\n    if (getExtraProps) {\n      var extraProps = getExtraProps(data, index, dataIndex);\n\n      if (extraProps) {\n        if (process.env.NODE_ENV !== \"production\") {\n          if (extraProps.hasOwnProperty(propName)) {\n            throw new Error(\"getExtraProps must not override \" + propName);\n          }\n        }\n\n        Object.assign(props, extraProps);\n      }\n    }\n\n    return props;\n  };\n};\n\nexport var getRowProps = getPropsGetter(\"aria-rowindex\");\nexport var getCellProps = getPropsGetter(\"aria-colindex\");","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { getRowProps } from \"../../utils/extraPropsGetters\";\n\nvar Row = function Row(_ref) {\n  var getRowData = _ref.getRowData,\n      getRowExtraProps = _ref.getRowExtraProps,\n      rowIndex = _ref.rowIndex;\n  var rowData = getRowData(rowIndex);\n  return /*#__PURE__*/React.createElement(\"div\", getRowProps(rowData, rowIndex, rowIndex, getRowExtraProps), rowData);\n};\n\nRow.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  getRowData: PropTypes.func.isRequired,\n  rowIndex: PropTypes.number.isRequired,\n  getRowExtraProps: PropTypes.func\n} : {};\nexport default Row;","import React from \"react\";\nimport { observer } from \"mobx-react-lite\";\nimport useApi from \"../../useApi\";\n\nvar getVisibleRows = function getVisibleRows(rangeFrom, rangeTo, getRowData, getRowKey, getRowExtraProps, RowComponent) {\n  var result = [];\n\n  for (var rowKey; rangeFrom < rangeTo; rangeFrom++) {\n    rowKey = getRowKey ? getRowKey(rangeFrom) : rangeFrom;\n    result.push( /*#__PURE__*/React.createElement(RowComponent, {\n      getRowExtraProps: getRowExtraProps,\n      rowIndex: rangeFrom,\n      key: rowKey,\n      getRowData: getRowData\n    }));\n  }\n\n  return result;\n};\n\nvar Rows = function Rows(_ref) {\n  var getRowExtraProps = _ref.getRowExtraProps,\n      RowComponent = _ref.RowComponent;\n\n  var _useApi = useApi(),\n      startIndex = _useApi.startIndex,\n      endIndex = _useApi.endIndex,\n      getRowData = _useApi.getRowData,\n      getRowKey = _useApi.getRowKey;\n\n  return getVisibleRows(startIndex, endIndex, getRowData, getRowKey, getRowExtraProps, RowComponent);\n};\n\nexport default observer(Rows);","import React from \"react\";\nimport useApi from \"../useApi\";\nimport { observer } from \"mobx-react-lite\";\n\nvar Scroller = function Scroller(_ref) {\n  var Component = _ref.Component;\n\n  var _useApi = useApi(),\n      virtualTopOffset = _useApi.virtualTopOffset;\n  /*\r\n      Hmm, I can't put here more than ~ 3 000 000. Maybe need to put one more row in case this height is > 3 000 000\r\n  */\n\n\n  return /*#__PURE__*/React.createElement(Component, {\n    className: \"afvscr-scroller\",\n    \"aria-hidden\": \"true\",\n    style: {\n      height: virtualTopOffset\n    }\n  });\n};\n\nexport default observer(Scroller);","var commonDefaultProps = {\n  fixedSize: false,\n  rows: {\n    length: 0\n  },\n  overscanRowsCount: 4,\n  estimatedRowHeight: 16\n};\nexport default commonDefaultProps;","import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport React, { memo } from \"react\";\nimport PropTypes from \"prop-types\";\nimport Context from \"../Context\";\nimport useStore from \"../utils/useStore\";\nimport VariableSizeListStore from \"../models/VariableSizeList\";\nimport FixedSizeListStore from \"../models/FixedSizeList\";\nimport ScrollContainer from \"../common/ScrollContainer\";\nimport RowComponentDefault from \"./common/Row\";\nimport Rows from \"./common/Rows\";\nimport Scroller from \"../common/Scroller\";\nimport commonPropTypes from \"../commonPropTypes\";\nimport commonDefaultProps from \"../commonDefaultProps\";\nimport cx from \"../utils/cx\";\n\nvar List = function List(_ref) {\n  var fixedSize = _ref.fixedSize,\n      getRowData = _ref.getRowData,\n      getRowKey = _ref.getRowKey,\n      getRowExtraProps = _ref.getRowExtraProps,\n      estimatedRowHeight = _ref.estimatedRowHeight,\n      rows = _ref.rows,\n      overscanRowsCount = _ref.overscanRowsCount,\n      _ref$RowComponent = _ref.RowComponent,\n      RowComponent = _ref$RowComponent === void 0 ? RowComponentDefault : _ref$RowComponent,\n      dataRef = _ref.dataRef,\n      className = _ref.className,\n      props = _objectWithoutPropertiesLoose(_ref, [\"fixedSize\", \"getRowData\", \"getRowKey\", \"getRowExtraProps\", \"estimatedRowHeight\", \"rows\", \"overscanRowsCount\", \"RowComponent\", \"dataRef\", \"className\"]);\n\n  var _useStore = useStore(fixedSize ? FixedSizeListStore : VariableSizeListStore, dataRef, {\n    getRowData: getRowData,\n    getRowKey: getRowKey,\n    overscanRowsCount: overscanRowsCount,\n    estimatedRowHeightFallback: estimatedRowHeight,\n    rows: rows\n  }),\n      Store = _useStore[0],\n      scrollContainerRef = _useStore[1],\n      rowsContainerRef = _useStore[2];\n\n  return /*#__PURE__*/React.createElement(Context.Provider, {\n    value: Store\n  }, /*#__PURE__*/React.createElement(ScrollContainer, _extends({\n    className: cx(\"afvscr-list-wrapper\", className),\n    ref: scrollContainerRef\n  }, props), /*#__PURE__*/React.createElement(Scroller, {\n    Component: \"div\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    ref: rowsContainerRef\n  }, /*#__PURE__*/React.createElement(Rows, {\n    RowComponent: RowComponent,\n    getRowExtraProps: getRowExtraProps\n  }))));\n};\n\nList.propTypes = process.env.NODE_ENV !== \"production\" ? commonPropTypes : {};\nList.defaultProps = Object.assign({}, commonDefaultProps, {\n  /*\r\n      For 90% non-reactive solutions, which only provide new getRowData when data is changed, memo is ok.\r\n      If RowComponent should be wrapped my mobx observer - non-memo version should be imported.\r\n      memo(observer(RowComponentDefault)) will do the trick.\r\n  */\n  RowComponent: /*#__PURE__*/memo(RowComponentDefault)\n});\nexport default /*#__PURE__*/memo(List);"],"sourceRoot":""}